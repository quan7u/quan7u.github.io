<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>我的博客的设计思路</title>
    <link href="/design-of-my-blog/"/>
    <url>/design-of-my-blog/</url>
    
    <content type="html"><![CDATA[<h2 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h2><p>每篇博客需要一定的元信息来辅助管理，Hexo 等博客系统的做法都是通过 YAML front matter（类似文件头）来实现的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">标题</span><br><span class="hljs-attr">category:</span> <span class="hljs-string">分类</span><br><span class="hljs-attr">tag:</span> <span class="hljs-string">标签</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2021-11-14</span><br><span class="hljs-attr">status:</span> <span class="hljs-string">Draft|Published</span><br><span class="hljs-attr">slug:</span> <span class="hljs-string">链接资源名</span><br><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><h2 id="关键的依赖库"><a href="#关键的依赖库" class="headerlink" title="关键的依赖库"></a>关键的依赖库</h2><h3 id="commonmark-java"><a href="#commonmark-java" class="headerlink" title="commonmark-java"></a>commonmark-java</h3><p>仓库地址：<a href="https://github.com/commonmark/commonmark-java">https://github.com/commonmark/commonmark-java</a></p><p>这是一个实现了 commonmark 标准（一个 markdown 标准），用于解析和渲染 markdown 的 Java 依赖库</p><p>PS：这个库核心在于解析 markdown 语法，提供了简单转化为 HTML 的 API，没有对渲染转化做特别的处理，所以如果需要对转化渲染更精确的把控，需要对整个库进行更多的熟悉了解而不限于基础用法</p><h2 id="持续发布"><a href="#持续发布" class="headerlink" title="持续发布"></a>持续发布</h2><h3 id="WebHook"><a href="#WebHook" class="headerlink" title="WebHook"></a>WebHook</h3><p>考虑到 pull &amp; push 的速度，我的博客资源（文字 &amp; 图片）依托 Gitee</p><p>思路大概就是每次变更内容后，push 到仓库，Gitee 向我的服务进行一个回调<br>blog-server 收到回调后，重新把博客 load 到缓存中</p><h2 id="备案"><a href="#备案" class="headerlink" title="备案"></a>备案</h2><p>暂时不考虑备案，有点麻烦</p><p><a href="https://segmentfault.com/a/1190000006110417">页面字体</a></p><h2 id="回归-Hexo"><a href="#回归-Hexo" class="headerlink" title="回归 Hexo"></a>回归 Hexo</h2><p>备案太恶心了。。。</p>]]></content>
    
    
    <categories>
      
      <category>分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB 存储引擎</title>
    <link href="/mysql-innodb.html"/>
    <url>/mysql-innodb.html</url>
    
    <content type="html"><![CDATA[<h2 id="原文档"><a href="#原文档" class="headerlink" title="原文档"></a>原文档</h2><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html">官方文档</a></p><h2 id="InnoDB-与-ACID-模型"><a href="#InnoDB-与-ACID-模型" class="headerlink" title="InnoDB 与 ACID 模型"></a>InnoDB 与 ACID 模型</h2><p>InnoDB 对数据库 ACID 原则进行了严格实现，不需要重新造轮子（一致性检查、崩溃恢复机制）</p><p>如果有额外的软件保护措施，比如超可靠的硬件，或应用程序可以容忍少量数据丢失（不一致），可以调整MySQL设置，以牺牲一些ACID的可靠性来换取更大的性能或吞吐量。</p><ul><li><strong>A</strong>: atomicity.</li><li><strong>C</strong>: consistency.</li><li><strong>I</strong>: isolation.</li><li><strong>D</strong>: durability.</li></ul><h3 id="实现-acid-的相关功能"><a href="#实现-acid-的相关功能" class="headerlink" title="实现 acid 的相关功能"></a>实现 acid 的相关功能</h3><h4 id="atomicity-原子性"><a href="#atomicity-原子性" class="headerlink" title="atomicity 原子性"></a>atomicity 原子性</h4><p>主要涉及事务，相关特性有：</p><ul><li>autocommit 设置</li><li>COMMIT 语句</li><li>ROLLBACK 语句</li></ul><h4 id="consistency-一致性"><a href="#consistency-一致性" class="headerlink" title="consistency 一致性"></a>consistency 一致性</h4><p>主要涉及 InnoDB 内部保证崩溃时的数据完整性，相关特性包括：</p><ul><li>InnoDB doublewrite buffer</li><li>InnoDB crash recovery</li></ul><h4 id="isolation-隔离性"><a href="#isolation-隔离性" class="headerlink" title="isolation 隔离性"></a>isolation 隔离性</h4><p>主要涉及 InnoDB 事务，尤其是应用于每个事务的隔离级别，相关特性包括：</p><ul><li>autocommit 设置</li><li>事务隔离级别和 SET TRANSACTION 语句</li><li>InnoDB 锁的底层细节</li></ul><h4 id="durability-持久性"><a href="#durability-持久性" class="headerlink" title="durability 持久性"></a>durability 持久性</h4><ul><li>InnoDB doublewrite buffer 双写缓冲区</li><li>变量 innodb_flush_log_at_trx_commit </li><li>变量 sync_binlog </li><li>变量 innodb_file_per_table </li><li>存储设备（如磁盘驱动、SSD 或 RAID）的写缓冲区</li><li>存储设备中的电池备份缓存（battery-backed cache write）</li><li>用于运行 MySQL 的操作系统，特别是对 fsync() 系统调用的支持</li><li>不间断的电源（UPS），保护所有服务器和数据</li><li>备份策略（如备份的频率、类型以及保留周期）</li></ul><h2 id="5-InnoDB-内存结构"><a href="#5-InnoDB-内存结构" class="headerlink" title="5 InnoDB 内存结构"></a>5 InnoDB 内存结构</h2><p><img src="/mysql-innodb/Untitled-16495187354161.png" alt="Untitled-16495187354161"></p><p>由图可以看到在 InnoDB 中，存在 Buffer Pool、Change Buffer、自适应哈希索引和 Log Buffer 等结构。</p><h3 id="5-1-Buffer-Pool"><a href="#5-1-Buffer-Pool" class="headerlink" title="5.1 Buffer Pool"></a>5.1 Buffer Pool</h3><p>Buffer Pool（缓冲池）是主存的一块区域，缓存表和索引数据用于访问。实现了直接从内存访问经常使用的数据，提升了处理速度。（在专用服务器上，高达 80% 的物理内存通常分配给缓冲池。）</p><p>为了提升大容量数据读取的效率，Buffer Pool 被划分为可以存储多行的页（Page）。</p><p>为了提升缓存的管理</p><ul><li>使用页的链表实现缓冲池</li><li>冷数据使用 LRU 算法的变体进行淘汰</li></ul><blockquote><p>💡 了解如何利用缓冲池将频繁访问的数据保存在内存中是 MySQL 调优的一个重要方向。</p></blockquote><h4 id="缓冲池的-LRU-算法"><a href="#缓冲池的-LRU-算法" class="headerlink" title="缓冲池的 LRU 算法"></a>缓冲池的 LRU 算法</h4><p>Buffer Pool 通过一个列表（List）使用 LRU 算法的变体对缓存进行管理。</p><p>当需要增加一个新的页（page）到 Buffer Pool 来增加空间时，最近最少使用的页将会被淘汰，然后将新的页加到列表中间。</p><p>这个中点插入策略将列表视为两个子列表：</p><ul><li>New Sublist：最近访问的、新页的子列表</li><li>Old Sublist：最近最少访问的、旧页的子列表</li></ul><p><img src="/mysql-innodb/Untitled%201-16601404298232.png" alt="Untitled 1"></p><p>这个算法保证了频繁使用的页在 new sublist 中。</p><p>Old sublist 包含很少使用的页；这些页等待被淘汰。</p><p>默认情况下，该算法的逻辑如下：</p><ul><li><p>3&#x2F;8 的 buffer pool 被用于 old sublist。</p></li><li><p>中点，是新老子列表的边界</p></li><li><p>当 InnoDB 将页读取到缓冲池中，最初会将页插入到中点（old sublist 的头部）。页能够被读取，可能是用户发起的操作例如 SQL 查询，或是 InnoDB 自动执行的预读操作。</p></li><li><p>访问 old list 中的页会使其变”年轻“，将其移动到 new sublist 的头部。</p><ul><li>如果页访问是出自用户操作，第一次访问立即发生，那么页则会被年轻化。</li><li>如果页访问是由于 InnoDB 的预读操作，第一次访问不会立即执行，甚至可能在页淘汰前也不会进行访问。</li></ul></li><li><p>伴随着数据库操作，buffer pool 中未访问的页通过向 list 的尾部移动来”老化“。</p><p>新老子列表的页都会随着其他页的插入、移动而”老化“。Old sublist 中的页也会随着新页插入到中点而”老化“。</p><p>最终，未使用的页面到达 old sublist 的尾部被淘汰</p></li></ul><h3 id="5-2-Change-Buffer"><a href="#5-2-Change-Buffer" class="headerlink" title="5.2 Change Buffer"></a>5.2 Change Buffer</h3><h3 id="5-3-Adaptive-Hash-Index"><a href="#5-3-Adaptive-Hash-Index" class="headerlink" title="5.3 Adaptive Hash Index"></a>5.3 Adaptive Hash Index</h3><h3 id="5-4-Log-Buffer（redo-log-buffer）"><a href="#5-4-Log-Buffer（redo-log-buffer）" class="headerlink" title="5.4 Log Buffer（redo log buffer）"></a>5.4 Log Buffer（redo log buffer）</h3><p>Log buffer 是一块内存区域，用于存储那些需要写入到磁盘日志文件的数据。</p><p>日志缓冲区的大小根据  <code>innodb_log_buffer_size</code> 来进行配置，默认配置为 16MB。其中的数据会定期刷到磁盘中。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>Log Buffer 的作用是不需要在事务提交之前将 redo log 写入磁盘。</p><p>较大的 Log Buffer 能够支持运行大型事务，所以，如果你的事务需要更新，插入或删除许多行时，增加 Log Buffer 的大小将会减少部分磁盘 I&#x2F;O。</p><blockquote><p>💡单个事务的日志不能拆开，无论该事务多大，也得确保一次性写入。如果超过，则需要暂存到磁盘。</p></blockquote><h4 id="刷盘（innodb-flush-log-at-trx-commit）"><a href="#刷盘（innodb-flush-log-at-trx-commit）" class="headerlink" title="刷盘（innodb_flush_log_at_trx_commit）"></a>刷盘（innodb_flush_log_at_trx_commit）</h4><p><code>innodb_flush_log_at_trx_commit</code> 变量，默认值为 1，在严格遵循 ACID 和性能之间选择</p><p>控制 log buffer 的内容如何写入并刷新到磁盘（刷盘），即写盘策略</p><table><thead><tr><th>变量值</th><th>策略</th><th>备注</th><th>影响</th></tr></thead><tbody><tr><td>0</td><td>每秒刷盘</td><td>在时间间隔中没有刷盘的事务日志，会在崩溃中丢失</td><td></td></tr><tr><td>1（完全符合 ACID，也是默认值）</td><td>将在每个事务提交时，进行刷盘</td><td></td><td></td></tr><tr><td>2</td><td>事务提交写到 page cache，每秒刷盘</td><td>在时间间隔中没有刷盘的事务日志，会在崩溃中丢失</td><td>MySQL崩溃不会丢失数据（已经写到 page cache 了）<br>服务器宕机则可能会丢失 1s 数据</td></tr></tbody></table><ul><li>设置为 0，每次事务提交都将 log 留在 buffer 中</li><li>设置为 1，每次事务提交直接将 log 持久化到磁盘中</li><li>设置为 2，每次事务提交只把 log 写到文件系统的 page cache</li></ul><p>Log buffer 的内容会定期刷新到磁盘，得益于 InnoDB 有一个后台线程，会把 log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。</p><p><code>innodb_flush_log_at_timeout</code> 变量控制日志刷新频率。 </p><h2 id="6-InnoDB-磁盘结构"><a href="#6-InnoDB-磁盘结构" class="headerlink" title="6 InnoDB 磁盘结构"></a>6 InnoDB 磁盘结构</h2><p><img src="/mysql-innodb/Untitled-16495188199132.png" alt="Untitled-16495188199132"></p><h3 id="6-1表"><a href="#6-1表" class="headerlink" title="6.1表"></a>6.1表</h3><h3 id="6-2-索引"><a href="#6-2-索引" class="headerlink" title="6.2 索引"></a>6.2 索引</h3><h4 id="聚簇索引和辅助索引"><a href="#聚簇索引和辅助索引" class="headerlink" title="聚簇索引和辅助索引"></a>聚簇索引和辅助索引</h4><p>每个 InnoDB 表都有一个叫做聚簇索引的特殊索引，存储行数据。</p><p>通常，聚簇索引等同于主键。</p><p>为了从查询、插入和其他数据库操作中获得最佳性能，了解 InnoDB 如何使用聚簇索引来优化常见的查找和 DML 操作是很重要的。</p><ul><li>如果没有逻辑唯一的非空列或一组列可以作为主键，则添加一个自动递增列。自动递增列值是唯一的，并在插入新行时自动添加。</li><li>如果你没有为一个表定义一个 <code>PRIMARY KEY</code>，InnoDB 会使用第一个 <code>UNIQUE</code> 索引作为聚簇索引，并且所有的键列都定义为 <code>NOT NULL</code>。</li><li>如果一个表没有<code>PRIMARY KEY</code>或合适的<code>UNIQUE</code>索引，InnoDB会在一个包含行 ID 值的合成列上生成一个名为 <code>GEN_CLUST_INDEX</code> 的隐藏聚集索引。这些行按照InnoDB分配的行ID排序。行ID是一个6字节字段，在插入新行时单调增加。因此，按行ID排序的行在物理上是按插入顺序排列的。</li></ul><h5 id="聚簇索引是如何提升查询速度？"><a href="#聚簇索引是如何提升查询速度？" class="headerlink" title="聚簇索引是如何提升查询速度？"></a>聚簇索引是如何提升查询速度？</h5><p>通过聚簇索引访问某个数据行非常快，因为索引搜索直接指向包含行数据的页面（page）。</p><p>如果表特别大，相比行数据和索引在不同页上的存储结构（比如 myisam 引擎），这将大大节省磁盘 I&#x2F;O 资源。</p><h5 id="聚簇索引与二级索引的关联？"><a href="#聚簇索引与二级索引的关联？" class="headerlink" title="聚簇索引与二级索引的关联？"></a>聚簇索引与二级索引的关联？</h5><p>聚簇索引以外的索引被称为二级索引。</p><p>在 InnoDB 中，二级索引存储了主键列，以及二级索引指定的列数据。InnoDB 使用这个主键值来搜索聚簇索引中的行。</p><p>如果主键很长，则二级索引将占用更多空间，因此主键较短是有利的。</p><h4 id="InnoDB-索引的物理结构"><a href="#InnoDB-索引的物理结构" class="headerlink" title="InnoDB 索引的物理结构"></a>InnoDB 索引的物理结构</h4><p>除了空间索引外，InnoDB 索引都是 <code>B-tree</code> 数据结构。空间索引使用 R-trees，是用于索引多维数据的专用数据结构。索引记录存储在 <code>B-tree</code> 或 <code>R-tree</code> 数据结构的叶页中。索引页的默认大小是 <code>16KB</code>。页面大小是由MySQL实例初始化时设置的 <code>innodb_page_size</code> 大小决定的。</p><p>当新记录插入 InnoDB 聚簇索引时，InnoDB 会试图将页面的 <code>1/16</code> 空出来留给将来插入和更新索引记录。如果索引记录按顺序插入（升序或降序），最终插满的索引页大约是 <code>15/16</code> 。如果以随机顺序插入记录，索引页容量大概在 <code>1/2</code> 到 <code>15/16</code> 。</p><p>InnoDB 在创建或重建 B-tree 索引时执行批量加载。这种创建索引的方法称为有序索引构建。<code>innodb_fill_factor</code> 变量定义了在有序索引构建期间，每个 B-tree 页面上可被填充的空间的百分比，剩下的空间留给未来存储的指数增长。空间索引不支持排序索引构建。<code>innodb_fill_factor</code> 设置为 100，会将 <code>1/16</code> 的空间在聚类索引页面中保存，用于未来存储的指数增长。</p><p>如果 InnoDB 索引页的填充因子低于 MERGE THRESHOLD（没有指定默认是 50%），InnoDB 会压缩索引树来释放页空间。MERGE THRESHOLD 适用于 B-tree 和 R-tree。</p><h4 id="有序索引构建"><a href="#有序索引构建" class="headerlink" title="有序索引构建"></a>有序索引构建</h4><p>InnoDB 在创建或重建 B-tree 索引时执行批量加载。这种创建索引的方法称为有序索引构建。空间索引不支持有序索引构建。</p><p>构建索引有三个阶段。</p><ol><li>扫描聚簇索引，生成索引项并添加到排序缓冲区中。排序缓冲区满了之后，索引项排好序以后写到一个临时中间文件。这个过程称为“run”。</li><li>当一或多次“run”之后，对临时文件内的所有索引项做归并排序。</li><li>有序的索引项插入到 B-tree。</li></ol><h4 id="6-2-4-InnoDB-全文索引"><a href="#6-2-4-InnoDB-全文索引" class="headerlink" title="6.2.4 InnoDB 全文索引"></a>6.2.4 InnoDB 全文索引</h4><blockquote><p>InnoDB 1.2.x 版本开始，即 MySQL 5.6 开始，InnoDB 就开始支持全文索引了，拥有 MyISAM 全文索引的所有特性</p></blockquote><p>底层索引结构——倒排索引（inverted index）</p><p>通常用关联数组进行实现：</p><p><img src="/mysql-innodb/image-20220704111510566.png" alt="image-20220704111510566"></p><h3 id="6-4-Doublewrite-Buffer-双写缓冲区"><a href="#6-4-Doublewrite-Buffer-双写缓冲区" class="headerlink" title="6.4 Doublewrite Buffer 双写缓冲区"></a>6.4 Doublewrite Buffer 双写缓冲区</h3><blockquote><p>在上面提到过原子性和持久性的保证都与 doublewrite buffer 有关，也可以说它保证了数据页的可靠性。</p></blockquote><p>InnoDB 读写数据都是以 page 为单位的，在写入数据文件前，会把 page 写到 dblwr（双写文件名后缀为 .dblwr）。</p><blockquote><p>参考《MySQL 技术内幕》</p><p>刷新脏页时</p><ol><li>memcpy 函数将脏页复制到内存中的 dblwr</li><li>dblwr 顺序写入共享表空间的物理磁盘，随即调用 fsync 函数同步</li><li>dblwr 完成 page 写入后，再将 dblwr 的 page 写到各个表空间文件中</li></ol></blockquote><p> <strong>查看 dblwr 运行情况</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">GLOBAL</span> STATUS <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;innodb_dblwr%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/mysql-innodb/image-20220414232545331.png" alt="image-20220414232545331"></p><blockquote><p>《MySQL 技术内幕》的示例中，页数&#x2F;写入次数是  64:1，表示系统高峰如果小于这个比例说明写入压力并不高。而上图在我们生产环境其中一个数据库中，这个比例已经接近 2:1，侧面反映系统写入压力还是挺高的……</p></blockquote><p><strong>关闭 dblwr 功能</strong></p><p>设置 innodb_doublewrite 为 0 </p><p>或 启动实例时带上 –skip-innodb-doublewrite 参数</p><blockquote><p>主从部署时，需要提供较快的性能，可以考虑关闭 salve server 的双写</p><p>但任何时候需要提供高可靠的实例（master server），都应该确保开启双写</p></blockquote><h3 id="6-5-Redo-Log"><a href="#6-5-Redo-Log" class="headerlink" title="6.5 Redo Log"></a>6.5 Redo Log</h3><p>redo log 是一种基于磁盘的数据结构，在<strong>崩溃恢复</strong>期间用于纠正未完成事务写入的数据。</p><p>在正常操作期间，redo log 对 SQL 语句或底层 API 调用修改表数据的请求进行编码。</p><p>初始化期间和接受连接之前，意外关闭前未完成的数据文件更新将自动重放（replay）。</p><p>默认情况下，redo log 在磁盘上由两个名为 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> 的文件作物理表示。</p><p>redo log 中的数据按照受影响的记录进行编码；这些数据统称为 redo。</p><p>MySQL 以循环的方式写 redo log。通过 redo log 的数据通过不断增加的 <code>LSN</code> 值（Log Sequence Number）表示。</p><p><strong>修改 redo log 的数量或大小</strong></p><p>操作步骤：</p><ol><li>停止 MySQL 服务器，确保关闭时没有报错。</li><li>编辑 <code>my.cnf</code> 更改日志文件配置。<ul><li>大小：<code>innodb_log_file_size</code></li><li>数量：<code>innodb_log_files_in_group</code></li></ul></li><li>再次启动 MySQL 服务器。</li></ol><blockquote><p>如果 InnoDB 检测到 <code>innodb_log_file_size</code>  与重做日志文件大小不一致，它会写一个日志检查点，关闭并删除旧的日志文件，按请求的大小创建新的日志文件，并打开新的日志文件。</p></blockquote><p><strong>组提交用于 redo log 刷新</strong></p><p>InnoDB，跟其他任何兼容 ACID 的数据库引擎一样，会在事务提交之前，将 redo log 刷新到磁盘。（<strong>刷盘根据实际配置策略</strong>）</p><p>InnoDB 使用组提交功能将多个刷新请求分在一组，以避免每次提交都要刷新。对多个同时提交的用户事务执行提交操作，通过组提交，InnoDB 只对日志文件进行一次写操作，显著提高了吞吐量。</p><h3 id="6-6-Undo-Logs"><a href="#6-6-Undo-Logs" class="headerlink" title="6.6 Undo Logs"></a>6.6 Undo Logs</h3><p>undo log 是与单个读-写事务相关联的 undo log 记录的集合。undo log 记录包含如何撤消事务对聚集索引记录的最新更改的信息。</p><p>如果另一个事务需要查看作为一致读操作一部分的原始数据，则从 undo log 记录中检索未修改的数据。</p><p>undo log 存在于 undo log 日志段中，undo log 日志段包含在rollback 回滚段中。rollback 回滚段驻留在 undo 表空间和全局临时表空间中。</p><p>驻留在全局临时表空间中的 undo logs 用于修改用户定义临时表中数据的事务。这些 undo log 不需要 redo log，因为崩溃恢复不需要它们（临时表的事务）。它们仅用于服务器运行时的回滚。这种类型的 undo log 可以避免 redo log 的 I&#x2F;O，从而提高性能。</p><h2 id="7-InnoDB-锁和事务模型"><a href="#7-InnoDB-锁和事务模型" class="headerlink" title="7 InnoDB 锁和事务模型"></a>7 InnoDB 锁和事务模型</h2><blockquote><p>如果需要实现大型数据库、数据库迁移或者 MySQL 调优，必须要了解锁和事务模型</p></blockquote><h3 id="7-1-InnoDB-锁"><a href="#7-1-InnoDB-锁" class="headerlink" title="7.1 InnoDB 锁"></a>7.1 InnoDB 锁</h3><h4 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h4><blockquote><p>InnoDB 实现了标准行级别的锁，分别是共享锁和独占锁</p></blockquote><ul><li>共享锁允许事务读行记录</li><li>独占锁允许事务更新或删除行记录</li></ul><p>共享锁可以立即获取，而独占锁的获取，必须等待持有独占锁的事务释放锁。</p><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>意向锁是表级锁，InnoDB 实现多粒度锁的手段，其实就是能够实现表锁和行锁并存。</p><blockquote><p>意向锁有两种：</p><ul><li><p>意向共享锁：表示事务打算在表中某行加共享锁，例如 <code>SELECT ... FOR SHARE</code></p></li><li><p>意向独占锁：表示事务打算在表中某行加独占锁，例如 <code>SELECT ... FOR UPDATE</code></p></li></ul><p>意向锁协议规定：</p><ul><li><p>事务如果需要获取表中某行的共享锁，必须先获取表的意向共享锁，或者更强的锁</p></li><li><p>事务如果需要获取表中某行的独占锁，就必须先获取表中的意向独占锁</p></li></ul><p>事务如果一直不能获取锁，则会一直阻塞，最终导致死锁、错误。</p><p>除了表的锁请求（如 <code>LOCK TABLES ... WRITE</code> ），意向锁都不会阻塞任何请求。</p></blockquote><p><strong>意向锁的主要设计目的是为了显示某人正在或将要锁定表中的某一行。</strong></p><table><thead><tr><th align="left"></th><th align="left"><code>X</code></th><th align="left"><code>IX</code></th><th align="left"><code>S</code></th><th align="left"><code>IS</code></th></tr></thead><tbody><tr><td align="left"><code>X</code></td><td align="left">Conflict</td><td align="left">Conflict</td><td align="left">Conflict</td><td align="left">Conflict</td></tr><tr><td align="left"><code>IX</code></td><td align="left">Conflict</td><td align="left">Compatible</td><td align="left">Conflict</td><td align="left">Compatible</td></tr><tr><td align="left"><code>S</code></td><td align="left">Conflict</td><td align="left">Conflict</td><td align="left">Compatible</td><td align="left">Compatible</td></tr><tr><td align="left"><code>IS</code></td><td align="left">Conflict</td><td align="left">Compatible</td><td align="left">Compatible</td><td align="left">Compatible</td></tr></tbody></table><h4 id="记录锁（行锁）"><a href="#记录锁（行锁）" class="headerlink" title="记录锁（行锁）"></a>记录锁（行锁）</h4><p>索引记录锁</p><p>如果没有定义索引，InnoDB 也会创建隐藏的索引列用于锁行。</p><h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><blockquote><p>幻读的定义</p><p>触发条件：当前读（一致性读）比如 for update 时</p><p>场景：专指新插入的行</p><p>问题</p><ol><li>破坏了行锁的语义（例如给 id 为 1 的行加锁后，又插入了 n 条 id 为 1 的数据，行锁就存在问题了）</li><li>数据和日志的逻辑不一致</li></ol><p>即使给所有已存在的行加锁（而新增的行还未插入，不存在也就加不了锁），阻止不了新纪录的插入，所以幻读需要单独解决</p></blockquote><p>间隙的定义：</p><ul><li>第一个索引记录之前的间隙</li><li>索引记录之间的间隙</li><li>最后一个索引记录之后的间隙</li></ul><p>例如 <code>SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;</code> 会阻止其它事务插入 t.c1 为 15 的数据。</p><blockquote><p>无论列中是否已经有这样的值，因为范围内所有现有值之间的差距是锁定的。</p></blockquote><p>如果使用唯一索引来搜索，对唯一行锁定，是不需要间隙锁的。（如果搜索条件只包含多列唯一索引的部分列，间隙锁还是会生效）</p><p>举个例子，如果 id 列有唯一索引，下面的语句只会对 id 为 100 的行使用<code>索引记录锁</code> ，其它会话是否在前后间隙插入数据并不重要。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> child <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>如果 id 没有索引，或者索引不唯一，则上面的语句将锁定前面的间隙。</p><p>间隙锁之间不存在冲突。比如，在同一个间隙，事务 A 持有一个共享间隙锁，事务 B 持有一个独占间隙锁。</p><p>允许冲突间隙锁的原因是，如果从索引中清除一条记录，则必须合并由不通事务持有的间隙锁。</p><p>间隙锁在 InnoDB 中代表着“purely inhibitive”，意思是间隙锁唯一的目的就是防止其他事务插入间隙。</p><p>间隙锁可以共存：</p><ul><li>一个事务使用间隙锁不会阻止另一个事务使用同一个间隙锁。</li><li>共享锁和独占锁之间没有区别。它们彼此并不冲突，它们执行相同的功能。</li></ul><p>间隙锁是个动态的概念</p><h4 id="Next-Key-锁"><a href="#Next-Key-锁" class="headerlink" title="Next-Key 锁"></a>Next-Key 锁</h4><p>索引记录锁和间隙锁的组合。</p><p>InnoDB 执行行级锁的方式是这样的:当它搜索或扫描表索引时，它会在遇到的索引记录上设置共享锁或排他锁。因此，行级锁实际上是索引记录锁。</p><p>如果索引包含值 10,11,13 和 20，next-key 锁包含以下范围：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">(negative infinity, <span class="hljs-number">10</span>]<br>(<span class="hljs-number">10</span>, <span class="hljs-number">11</span>]<br>(<span class="hljs-number">11</span>, <span class="hljs-number">13</span>]<br>(<span class="hljs-number">13</span>, <span class="hljs-number">20</span>]<br>(<span class="hljs-number">20</span>, positive infinity)<br></code></pre></td></tr></table></figure><p>用于解决幻读。</p><p>InnoDB 执行行级锁的方式是这样的:当它搜索或扫描表索引时，它会在遇到的索引记录上设置共享锁或排他锁。</p><p>因此，行级锁实际上是索引记录锁。</p><p>此外，索引记录上的next-key锁也会影响索引记录之前的间隙。也就是说，next-key锁是索引记录锁加上索引记录之前间隙上的间隙锁。</p><p>如果一个会话在索引中的记录 <code>R</code> 上有一个共享锁或排他锁，那么另一个会话就不能按照索引顺序在 <code>R</code> 之前的间隙中立即插入新的索引记录。</p><h4 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h4><p>插入意图锁是一种间隙锁，由 <code>insert</code> 操作在行插入之前设置。</p><h4 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h4><p>是一种特殊的表级锁，由插入到具有 <code>AUTO- INCREMENT</code> 列的表中的事务获取。</p><p>在最简单的情况下，如果一个事务正在向表中插入值，任何其他事务都必须等待对该表的插入，以便由第一个事务插入的行接收连续的主键值。</p><h4 id="谓词锁（用于空间索引）"><a href="#谓词锁（用于空间索引）" class="headerlink" title="谓词锁（用于空间索引）"></a>谓词锁（用于空间索引）</h4><h3 id="7-5-死锁"><a href="#7-5-死锁" class="headerlink" title="7.5 死锁"></a>7.5 死锁</h3><h4 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h4><h2 id="18-InnoDB-备份和恢复"><a href="#18-InnoDB-备份和恢复" class="headerlink" title="18 InnoDB 备份和恢复"></a>18 InnoDB 备份和恢复</h2><h3 id="18-1-InnoDB-备份"><a href="#18-1-InnoDB-备份" class="headerlink" title="18.1 InnoDB 备份"></a>18.1 InnoDB 备份</h3><p>安全地管理数据库的关键，就是定期备份。根据数据量、MySQL 服务实例数量和数据库工作负载，可以单独或组合使用这些备份技术：MySQL 企业级的热备；MySQL 服务关闭时通过复制文件进行冷备份；使用 mysqldump 进行逻辑备份，一般用于较小的数据量或库表结构。</p><p>热备份和冷备份是复制实际数据文件的物理备份，mysqld 服务可以直接使用这些文件来更快地恢复数据。</p><h4 id="热备份"><a href="#热备份" class="headerlink" title="热备份"></a>热备份</h4><h4 id="冷备份"><a href="#冷备份" class="headerlink" title="冷备份"></a>冷备份</h4><h4 id="使用-mysqldump-逻辑备份"><a href="#使用-mysqldump-逻辑备份" class="headerlink" title="使用 mysqldump 逻辑备份"></a>使用 mysqldump 逻辑备份</h4><h2 id="19-InnoDB-和-MySQL-复制机制"><a href="#19-InnoDB-和-MySQL-复制机制" class="headerlink" title="19 InnoDB 和 MySQL 复制机制"></a>19 InnoDB 和 MySQL 复制机制</h2><p>在复制源上失败的事务不会影响复制。MySQL 的复制基于二进制日志，MySQL 在二进制日志中写入修改数据的 SQL 语句。一个失败的事务(例如，由于违反外键，或因为它被回滚)不会被写入二进制日志，因此它不会被发送到副本。</p><h2 id="22-InnoDB-的限制"><a href="#22-InnoDB-的限制" class="headerlink" title="22 InnoDB 的限制"></a>22 InnoDB 的限制</h2><p>InnoDB 存储引擎在表，索引，表空间等方面存在限制：</p><ul><li><p>一张表最多包含 1017 列</p></li><li><p>一张表最多有 64 个二级索引</p></li><li><p>多列索引最多允许 16 列。超过这个限制会返回错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ERROR 1070 (42000): Too many key parts specified; max 16 parts allowed<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>InnoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 启动的一系列</title>
    <link href="/Spring%20%E5%90%AF%E5%8A%A8%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97/"/>
    <url>/Spring%20%E5%90%AF%E5%8A%A8%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h1><ul><li>元信息配置 - XML、注解配置 Bean</li><li>使用 BeanDefinition 包装 Bean 元信息</li><li>注册 BeanDefinition</li></ul><p>组件构成：bean、context、core</p><h1 id="调用-BeanFactoryPostProcessor"><a href="#调用-BeanFactoryPostProcessor" class="headerlink" title="调用 BeanFactoryPostProcessor"></a>调用 BeanFactoryPostProcessor</h1><p>核心方法 invokeBeanFactoryPostProcessors</p><p>实际上有两种后置处理器</p><ul><li><p>BeanFactoryPostProcessor</p></li><li><p>BeanDefinitionRegistryPostProcessor （继承于 <code>BeanFactoryPostProcessor</code>）</p></li></ul><p>流程</p><ol><li><p>创建 processedBeans 集合，记录已处理的 bean</p></li><li><p>获取 bean factory 内部的后置处理器，判断类型是否为 BeanDefinitionRegistryPostProcessors</p><ul><li><p>是 -&gt; 调用该后置处理器的 <code>postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)</code> 方法</p></li><li><p>否 -&gt; 仅加入到集合 <code>List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors</code> 中，无其它处理</p></li></ul></li><li><p>创建集合 <code>List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors</code></p></li><li><p>首先，调用实现了 <code>PriorityOrdered</code> 的 <code>BeanDefinitionRegistryPostProcessor</code></p><ol><li><p>从 bean factory 中根据类型 <code>BeanDefinitionRegistryPostProcessor.class</code> 获取 bean 名称数组</p></li><li><p>遍历数组，判断 bean 是否实现了 <code>PriorityOrdered.class</code> 接口</p><ul><li>是 -&gt; 根据名称 &amp; 类型获取 bean 并加入到集合 currentRegistryProcessors 中，名称加入到集合 processedBeans 中</li></ul></li><li><p>对集合 currentRegistryProcessors  进行排序</p></li><li><p>遍历 <code>currentRegistryProcessors</code>，调用 <code>postProcessBeanDefinitionRegistry</code> 方法</p><ul><li>💡<strong>这里调用了 ConfigurationClassPostProcessor，核心</strong></li></ul></li></ol></li><li><p>然后，调用实现了 <code>Ordered</code> 的 <code>BeanDefinitionRegistryPostProcessor</code></p><ol><li>从 bean factory 中根据类型 <code>BeanDefinitionRegistryPostProcessor.class</code> 获取 bean 名称数组</li><li>遍历数组，判断 bean 是否被处理过 &amp;&amp; 是否实现了 <code>Ordered.class</code> 接口<ul><li>是 -&gt; 根据名称 &amp; 类型获取 bean 并加入到集合 currentRegistryProcessors 中，名称加入到集合 processedBeans 中</li></ul></li><li>排序，同上 3.3</li><li>调用，同上 3.4</li></ol></li><li><p>最后，调用所有的 <code>BeanDefinitionRegistryPostProcessor</code>，直到没有没处理过的后置处理器</p><ul><li>获取 bean -&gt; 判断是否处理过 -&gt; 排序、调用</li></ul></li><li><p>调用上面所有已经处理过的 <code>BeanDefinitionRegistryPostProcessor</code> 的 <code>postProcessBeanFactory</code> 方法</p></li><li><p>调用 <code>regularPostProcessors</code>（内部的不是 <code>BeanDefinitionRegistryPostProcessor</code> 的 <code>BeanFactoryPostProcessor</code>）的<code>postProcessBeanFactory</code> 方法</p></li><li><p>后续处理 <code>BeanFactoryPostProcessor</code> 也是相似的流程，不再赘述</p></li></ol><h2 id="ConfigurationClassPostProcessor"><a href="#ConfigurationClassPostProcessor" class="headerlink" title="ConfigurationClassPostProcessor"></a>ConfigurationClassPostProcessor</h2><p>配置类后置处理器实现了 <code>BeanDefinitionRegistryPostProcessor</code>，拥有两个后置处理方法</p><p>流程</p><ol><li><p>获取注册表里的 <code>beanDefinitionName</code> 数组（实际上就是获取 <code>DefaultListableBeanFactory</code> 的 <code>beanDefinitionNames</code> 集合</p></li><li><p>遍历检查 <code>beanDefinition</code> 是否是配置类</p></li><li><p>解析每个 @Configuration 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (bd <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) &#123;<br>    parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bd <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;<br>    parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    parse(bd.getBeanClassName(), holder.getBeanName());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>parse 内部递归处理配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 递归处理配置类及其父类</span><br><span class="hljs-type">SourceClass</span> <span class="hljs-variable">sourceClass</span> <span class="hljs-operator">=</span> asSourceClass(configClass, filter);<br><span class="hljs-keyword">do</span> &#123;<br>    sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>处理 <code>beanDefinition</code> 的属性，比如基础包路径（<code>basePackges</code>）、懒加载、过滤器等</p><p><img src="/Spring%20%E5%90%AF%E5%8A%A8%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97/image-20211115153512549.png" alt="image-20211115153512549"></p><ul><li>当没有使用 <code>componentScan</code> 注解且 <code>basePackges</code> 为空时，会使用启动类 <code>xxxApplication</code> 的全限定类路径</li></ul></li><li><p>扫描路径下的资源（.class）但排除对配置类本身的处理</p><ol><li><p>判断类不匹配任何排除过滤器（<code>excludeFilters</code>）并至少匹配一个包含过滤器（<code>includeFilters</code>）</p><p>这里的包含过滤器有两个，一个是 <code>Component</code> 的，一个是 <code>ManagedBean</code> 的</p><p><img src="/Spring%20%E5%90%AF%E5%8A%A8%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97/image-20211115162814722.png" alt="image-20211115162814722"></p></li><li><p>判读是否存在 <code>@Conditional</code> 注解，需要跳过</p></li></ol></li><li><p>获取到引导启动类路径下的所有 bean 加入到 <code>candidates</code> 候选集合中，对候选集合继续补充更多设置属性（比如什么 Lazy、Primary、DependsOn 等）</p></li><li><p>检查 bean 名称冲突</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (checkCandidate(beanName, candidate)) &#123;<br>    <span class="hljs-comment">// 无冲突 -&gt; 调用 `registerBeanDefinition` 注册 `BeanDefinition` (将 bean 定义加到 bean factory 的集合中)</span><br>    <span class="hljs-type">BeanDefinitionHolder</span> <span class="hljs-variable">definitionHolder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionHolder</span>(candidate, beanName);<br>    definitionHolder =<br>        AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="hljs-built_in">this</span>.registry);<br>    beanDefinitions.add(definitionHolder);<br>    registerBeanDefinition(definitionHolder, <span class="hljs-built_in">this</span>.registry);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>返回从引导类 <code>xxxApplication</code> 扫描到的 <code>beanDefinition</code> 集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从引导类扫描出一堆 bean 定义后，再从这些 bean 筛选出配置类继续扫描，需要的话会递归解析</span><br><span class="hljs-keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;<br>    <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">bdCand</span> <span class="hljs-operator">=</span> holder.getBeanDefinition().getOriginatingBeanDefinition();<br>    <span class="hljs-keyword">if</span> (bdCand == <span class="hljs-literal">null</span>) &#123;<br>        bdCand = holder.getBeanDefinition();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="hljs-built_in">this</span>.metadataReaderFactory)) &#123;<br>        <span class="hljs-comment">// BeanDefinition 是配置类 -&gt; 解析</span><br>        parse(bdCand.getBeanClassName(), holder.getBeanName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解析：从源类读取注解，成员和方法</p><ol><li>首先，递归处理所有成员（嵌套）类</li><li>处理所有的 <code>@PropertySource</code> 注解</li><li>处理所有的 <code>@ComponentScan</code> 注解</li><li>处理所有的 <code>@Import</code> 注解</li><li>处理所有的 <code>@ImportResource</code> 注解</li><li>逐个处理 <code>@Bean</code> 方法</li><li>处理接口默认方法（Java 8+</li><li>如果存在继承，则处理父类</li></ol></li><li><p>解析的最后一步，延迟处理配置类的类定义，填充配置类的对象集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 对配置类 @Configuration 的 @Import 进行处理 </span><br><span class="hljs-built_in">this</span>.deferredImportSelectorHandler.process();<br></code></pre></td></tr></table></figure><p><img src="/Spring%20%E5%90%AF%E5%8A%A8%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97/image-20211116102630752.png" alt="image-20211116102630752"></p><p>可以看到获取候选配置拿到了大量的自动配置的类</p><ol><li><p>根据条件过滤器做筛选操作</p><p><img src="/Spring%20%E5%90%AF%E5%8A%A8%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97/image-20211116104126896.png" alt="image-20211116104126896"></p></li><li><p><code>processImports</code> 递归处理 import 的类，回到第 4 步的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 候选类不是 ImportSelector 也不是 ImportBeanDefinitionRegistrar -&gt;</span><br><span class="hljs-comment">// 作为 @Configuration 类处理</span><br><span class="hljs-built_in">this</span>.importStack.registerImport(<br>    currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());<br>processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter);<br></code></pre></td></tr></table></figure></li></ol></li><li><p>至此，解析操作完成</p></li></ol><p><img src="/Spring%20%E5%90%AF%E5%8A%A8%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97/image-20211115174354950.png" alt="image-20211115174354950"></p><p>可以看到除了在项目中定义的 <code>@Controller</code> 、<code>@Component</code> 、<code>@Configuration</code> 等配置类之外，还有许多自动配置的类</p><h1 id="注册-Bean-后置处理器"><a href="#注册-Bean-后置处理器" class="headerlink" title="注册 Bean 后置处理器"></a>注册 Bean 后置处理器</h1><blockquote><p>org.springframework.context.support.AbstractApplicationContext#registerBeanPostProcessors</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注册用于拦截 bean 创建的处理器</span><br>registerBeanPostProcessors(beanFactory);<br></code></pre></td></tr></table></figure><p>根据优先级对 BeanPostProcessor 进行了排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;String&gt; orderedPostProcessorNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;String&gt; nonOrderedPostProcessorNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br>    <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;<br>        <span class="hljs-comment">// 实例化</span><br>        <span class="hljs-type">BeanPostProcessor</span> <span class="hljs-variable">pp</span> <span class="hljs-operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);<br>        priorityOrderedPostProcessors.add(pp);<br>        <span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;<br>            internalPostProcessors.add(pp);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;<br>        orderedPostProcessorNames.add(ppName);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        nonOrderedPostProcessorNames.add(ppName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>按照 PriorityOrdered ——&gt; Ordered ——&gt; regular ——&gt; internal 的顺序</p><p>依次进行初始化（BeanFactory.getBean）和注册（beanFactory.addBeanPostProcessor）</p><h1 id="完成-BeanFactory-初始化"><a href="#完成-BeanFactory-初始化" class="headerlink" title="完成 BeanFactory 初始化"></a>完成 BeanFactory 初始化</h1><blockquote><p>org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这一步完成 BeanFactory 上下文的初始化</span><br><span class="hljs-comment">// 实例化所有剩余的（非懒加载的）单例 bean</span><br>finishBeanFactoryInitialization(beanFactory);<br></code></pre></td></tr></table></figure><p>3 个 Map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Cache of singleton objects: bean name to bean instance. */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">256</span>);<br><br><span class="hljs-comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br><br><span class="hljs-comment">/** Cache of early singleton objects: bean name to bean instance. */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** List of bean definition names, in registration order. */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> List&lt;String&gt; beanDefinitionNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">256</span>);<br></code></pre></td></tr></table></figure><p>遍历 beanDefinitionNames，如果 BeanDefinition 符合非抽象 &amp; 单例 &amp; 非懒加载，就会进行 getBean 操作</p><p>public 的 getBean 方法会调用 doGetBean 方法，通过入参控制逻辑</p><p><img src="/Spring%20%E5%90%AF%E5%8A%A8%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97/image-20211122160043672.png" alt="image-20211122160043672"></p><p>如果早期手动注册过单例对象，直接用单例缓存（singleton cache）返回</p><p><img src="/Spring%20%E5%90%AF%E5%8A%A8%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97/image-20211122161455795.png" alt="image-20211122161455795"></p><p>一些前置校验操作</p><ul><li><p>检查当前线程是否存在创建动作，这个操作可以检测到 Spring 不可解决的循环依赖</p></li><li><p>检查工厂中是否存在 BeanDefinition</p></li><li><p>判断本次操作是否<strong>只做类型检查，而不使用 Bean</strong>，剪枝思维吧，也是通过增加入参（增加）控制方法逻辑</p></li><li><p>处理 @DependsOn 注解，确保当前 Bean 依赖的对象先行初始化</p></li></ul><p>🚩创建 Bean 实例，此处分为 单例、多例和其它，重点还是放在单例上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Create bean instance.</span><br><span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>    <span class="hljs-comment">// 当 BeanDefinition 为单例时进入此分支</span><br>    <span class="hljs-comment">// 调用 public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span><br>    <span class="hljs-comment">// ObjectFactory 是一个函数式接口，只有一个 getObject 方法，此处对其实现</span><br>    <span class="hljs-comment">// 属于是函数式编程中常见的方法传递</span><br>    <span class="hljs-comment">// 下一步进入 getSingleton 方法</span><br>    sharedInstance = getSingleton(beanName, () -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>            <span class="hljs-comment">// Explicitly remove instance from singleton cache: It might have been put there</span><br>            <span class="hljs-comment">// eagerly by the creation process, to allow for circular reference resolution.</span><br>            <span class="hljs-comment">// Also remove any beans that received a temporary reference to the bean.</span><br>            destroySingleton(beanName);<br>            <span class="hljs-keyword">throw</span> ex;<br>        &#125;<br>    &#125;);<br>    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123;......<br></code></pre></td></tr></table></figure><p>getSingleton 方法内部将 Spring 对象池（singletonObjects）作为🔒，保证该段方法逻辑同步执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>            <span class="hljs-comment">// ......</span><br>            <span class="hljs-comment">// 单例创建前的回调</span><br>            beforeSingletonCreation(beanName);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 函数方法参数，实际调用外部传入的方法</span><br>                singletonObject = singletonFactory.getObject();<br>                newSingleton = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (IllegalStateException ex) &#123;<br>                <span class="hljs-comment">// ......</span><br>            &#125;<br>            <span class="hljs-keyword">catch</span> (BeanCreationException ex) &#123;<br>                <span class="hljs-comment">// ......</span><br>            &#125;<br>            <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;<br>                    <span class="hljs-built_in">this</span>.suppressedExceptions = <span class="hljs-literal">null</span>;<br>                &#125;<br>                <span class="hljs-comment">// 单例创建后的回调</span><br>                afterSingletonCreation(beanName);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (newSingleton) &#123;<br>                addSingleton(beanName, singletonObject);<br>            &#125;<br>            <span class="hljs-keyword">return</span> singletonObject;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="预初始化"><a href="#预初始化" class="headerlink" title="预初始化"></a>预初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preInstantiateSingletons</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>        logger.trace(<span class="hljs-string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span><br>    <span class="hljs-comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span><br>    List&lt;String&gt; beanNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-built_in">this</span>.beanDefinitionNames);<br><br>    <span class="hljs-comment">// Trigger initialization of all non-lazy singleton beans...</span><br>    <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>        <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition(beanName);<br>        <br>        <span class="hljs-keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;<br>            <span class="hljs-comment">// 非抽象 &amp; 单例 &amp; 非懒加载</span><br>            <span class="hljs-keyword">if</span> (isFactoryBean(beanName)) &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);<br>                <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> FactoryBean) &#123;<br>                    FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;<br>                    <span class="hljs-type">boolean</span> isEagerInit;<br>                    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span> &amp;&amp; factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean) &#123;<br>                        isEagerInit = AccessController.doPrivileged(<br>                            (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,<br>                            getAccessControlContext());<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        isEagerInit = (factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean &amp;&amp;<br>                                       ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (isEagerInit) &#123;<br>                        getBean(beanName);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                getBean(beanName);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Trigger post-initialization callback for all applicable beans...</span><br>    <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">singletonInstance</span> <span class="hljs-operator">=</span> getSingleton(beanName);<br>        <span class="hljs-keyword">if</span> (singletonInstance <span class="hljs-keyword">instanceof</span> SmartInitializingSingleton) &#123;<br>            <span class="hljs-type">SmartInitializingSingleton</span> <span class="hljs-variable">smartSingleton</span> <span class="hljs-operator">=</span> (SmartInitializingSingleton) singletonInstance;<br>            <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123;<br>                AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;<br>                    smartSingleton.afterSingletonsInstantiated();<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;, getAccessControlContext());<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                smartSingleton.afterSingletonsInstantiated();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos配置管理</title>
    <link href="/Nacos%20%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/"/>
    <url>/Nacos%20%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Data-Id-格式"><a href="#Data-Id-格式" class="headerlink" title="Data Id 格式"></a>Data Id 格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$&#123;prefix&#125;</span>-<span class="hljs-variable">$&#123;spring.profiles.active&#125;</span>.<span class="hljs-variable">$&#123;file-extension&#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>prefix</code> 默认为 <code>spring.application.name</code> 的值，也可以通过配置项 <code>spring.cloud.nacos.config.prefix</code>来配置。</li><li><code>spring.profiles.active</code> 即为当前环境对应的 profile，详情可以参考 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-profiles.html#boot-features-profiles">Spring Boot文档</a>。 <strong>注意：当 <code>spring.profiles.active</code> 为空时，对应的连接符 &#96;&#96; 也将不存在，dataId 的拼接格式变成 <code>$&#123;prefix&#125;.$&#123;file-extension&#125;</code></strong></li><li><code>file-exetension</code> 为配置内容的数据格式，可以通过配置项 <code>spring.cloud.nacos.config.file-extension</code> 来配置。目前只支持 <code>properties</code> 和 <code>yaml</code> 类型。</li></ul><h2 id="自动更新"><a href="#自动更新" class="headerlink" title="自动更新"></a>自动更新</h2><p>Spring Cloud 原生注解 <code>@RefreshScope</code> 实现配置自动更新</p><h2 id="profile-粒度"><a href="#profile-粒度" class="headerlink" title="profile 粒度"></a>profile 粒度</h2><p>配置加载的时：</p><p>加载 Data Id 为 <code>$&#123;spring.application.name&#125;.$&#123;file-extension:properties&#125;</code> 为前缀的基础配置，</p><p>还有 <code>$&#123;spring.application.name&#125;-$&#123;profile&#125;.$&#123;file-extension:properties&#125;</code> 的基础配置。</p><p>后者优于前者，会覆盖前者的配置</p><blockquote><p>💡 ${spring.profiles.active} 当通过配置文件来指定时必须放在 bootstrap 文件中</p></blockquote><p>实际生产落地时，通常启动服务时指定参数 -Dspring.profiles.active&#x3D;<profile> 来灵活切换</p><h2 id="自定义-namespace-命名空间"><a href="#自定义-namespace-命名空间" class="headerlink" title="自定义 namespace 命名空间"></a>自定义 namespace 命名空间</h2><p>命名空间的概念</p><blockquote><p>用于进行租户粒度的配置隔离。<br>不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。<br>Namespace 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</p></blockquote><p>团队人员不多的时候，会觉得这个直接依靠 profile 来控制开发测试不就可以了？</p><p>确实也是可以，又搜索了一些资料，存在即源于需求，在多人多团队开发时，需要屏蔽一些配置时，命名空间的作用就出来了。</p><p><img src="/Nacos%20%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/Untitled.png" alt="Untitled"></p><p>克隆功能也可以方便地将配置复制到各个命名空间</p><h2 id="自定义-group-组"><a href="#自定义-group-组" class="headerlink" title="自定义 group 组"></a>自定义 group 组</h2><p><code>$&#123;spring.cloud.nacos.config.group&#125;</code> 默认使用的是 DEFAULT_GROUP</p><blockquote><p>💡 该配置必须放在 bootstrap.properties 文件中。<br>添加配置时 Group 的值一定要和 <code>spring.cloud.nacos.config.group</code> 的配置值一致。</p></blockquote><h2 id="自定义扩展的-Data-Id"><a href="#自定义扩展的-Data-Id" class="headerlink" title="自定义扩展的 Data Id"></a>自定义扩展的 Data Id</h2><p><code>spring.cloud.nacos.config.ext-config</code> 配置的集合</p><p>既可以解决多个应用间配置共享的问题，又可以支持一个应用有多个配置文件</p><blockquote><p>💡 多个 Data Id 同时配置时，他的优先级关系是 spring.cloud.nacos.config.extension-configs[n].data-id 其中 n 的值越大，优先级越高。</p></blockquote><p>所以应该把共享配置放前面</p><blockquote><p>💡 spring.cloud.nacos.config.extension-configs[n].data-id 的值必须带文件扩展名，文件扩展名既可支持 properties，又可以支持 yaml&#x2F;yml。 此时 spring.cloud.nacos.config.file-extension 的配置对自定义扩展配置的 Data Id 文件扩展名没有影响。</p></blockquote><h2 id="配置的优先级"><a href="#配置的优先级" class="headerlink" title="配置的优先级"></a>配置的优先级</h2><p>Spring Cloud Alibaba Nacos Config 目前提供了三种配置能力从 Nacos 拉取相关的配置。</p><ul><li>A: 通过 <code>spring.cloud.nacos.config.shared-configs[n].data-id</code> 支持多个共享 Data Id 的配置</li><li>B: 通过 <code>spring.cloud.nacos.config.extension-configs[n].data-id</code> 的方式支持多个扩展 Data Id 的配置</li><li>C: 通过内部相关规则(应用名、应用名+ Profile &#x2F; <code>$&#123;spring.application.name&#125;-$&#123;profile&#125;</code> )自动生成相关的 Data Id 配置</li></ul><p>当三种方式共同使用时，他们的一个优先级关系是：<strong>A &lt; B &lt; C</strong></p><h2 id="共享配置方案设计"><a href="#共享配置方案设计" class="headerlink" title="共享配置方案设计"></a>共享配置方案设计</h2><p><a href="https://github.com/alibaba/spring-cloud-alibaba/issues/141">[discuss]: nacos config support sharing configuration with multi Applications · Issue #141 · alibaba&#x2F;spring-cloud-alibaba</a></p><h3 id="预期"><a href="#预期" class="headerlink" title="预期"></a>预期</h3><img src="Nacos%20%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/Untitled%201.png" alt="Untitled" style="zoom:50%;" /><h3 id="基于域名的配置方式给应用分组"><a href="#基于域名的配置方式给应用分组" class="headerlink" title="基于域名的配置方式给应用分组"></a><strong>基于域名的配置方式给应用分组</strong></h3><img src="Nacos%20%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/Untitled%202.png" alt="Untitled" style="zoom:50%;" /><ul><li>优点<ul><li>天然依托于域名的层次关系</li></ul></li><li>缺点<ul><li>受限于 group，Data Id 命名同样受限（个数、名称、扩展名）</li><li>学习成本、易错、复杂</li></ul></li></ul><h3 id="shared：自定义的方式来命名-Data-Id"><a href="#shared：自定义的方式来命名-Data-Id" class="headerlink" title="shared：自定义的方式来命名 Data Id"></a>shared：自定义的方式来命名 Data Id</h3><img src="Nacos%20%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/Untitled%203.png" alt="Untitled" style="zoom:50%;" /><p><code>shared.dataids</code> 按顺序依次加载，即越迟加载的优先级最高</p><ul><li>缺点<ul><li>扩展性差（不能配置 group、刷新等等）</li></ul></li></ul><h3 id="ext-config：通过类似面向对象方式的自定义配置"><a href="#ext-config：通过类似面向对象方式的自定义配置" class="headerlink" title="ext-config：通过类似面向对象方式的自定义配置"></a>ext-config：通过类似面向对象方式的自定义配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ext-config:</span><br>  <span class="hljs-comment"># 应用配置</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">data-id:</span> <span class="hljs-string">app.properties</span><br>    <span class="hljs-attr">group:</span> <span class="hljs-string">multi-data-ids</span><br>    <span class="hljs-attr">refresh:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 数据库配置</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">data-id:</span> <span class="hljs-string">datasource.properties</span><br>    <span class="hljs-attr">group:</span> <span class="hljs-string">multi-data-ids</span><br>  <span class="hljs-comment"># Redis 配置</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">data-id:</span> <span class="hljs-string">redis.properties</span><br>    <span class="hljs-attr">group:</span> <span class="hljs-string">multi-data-ids</span><br></code></pre></td></tr></table></figure><p>Nacos 支持第二种（shared.dataids）和第三种（ext-config）共存</p><blockquote><p>个人更推崇第三种 ext</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Nacos</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring 源码选读</title>
    <link href="/Spring%20%E6%BA%90%E7%A0%81%E9%80%89%E8%AF%BB/"/>
    <url>/Spring%20%E6%BA%90%E7%A0%81%E9%80%89%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="创建应用上下文"><a href="#创建应用上下文" class="headerlink" title="创建应用上下文"></a>创建应用上下文</h3><p>启动代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">SpringApplication.run(AppApplication.class, args);<br><br>↓ 重载方法<br><br><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title function_">run</span><span class="hljs-params">(String... args)</span> &#123;<br>......<br>context = createApplicationContext();<br>......<br>&#125;<br><br>↓ 定位到实际 create 的代码片段<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringApplication</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">ApplicationContextFactory</span> <span class="hljs-variable">applicationContextFactory</span> <br><span class="hljs-operator">=</span> ApplicationContextFactory.DEFAULT;<br><br><span class="hljs-keyword">protected</span> ConfigurableApplicationContext <span class="hljs-title function_">createApplicationContext</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.applicationContextFactory.create(<span class="hljs-built_in">this</span>.webApplicationType);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入到 ApplicationContextFactory 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span> <span class="hljs-comment">// 函数式接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApplicationContextFactory</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* ApplicationContextFactory 默认实现</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">ApplicationContextFactory</span> <span class="hljs-variable">DEFAULT</span> <span class="hljs-operator">=</span> (webApplicationType) -&gt; &#123;<br><span class="hljs-comment">// 真正创建应用上下文的代码</span><br>......<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建 ConfigurableApplicationContext</span><br><span class="hljs-comment"> */</span><br>ConfigurableApplicationContext <span class="hljs-title function_">create</span><span class="hljs-params">(WebApplicationType webApplicationType)</span>;<br>......<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到接口上标有 <code>@FunctionalInterface</code> 注解，表示该接口应该被设计成函数式接口（此注解跟 <code>@Override</code> 一样，起到编译期检查的作用，不是必须的）</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring IoC &amp; Beans</title>
    <link href="/Spring%20IoC%20&amp;%20Beans/"/>
    <url>/Spring%20IoC%20&amp;%20Beans/</url>
    
    <content type="html"><![CDATA[<h1 id="文档地址"><a href="#文档地址" class="headerlink" title="文档地址"></a>文档地址</h1><p><a href="https://docs.spring.io/spring-framework/docs/5.2.22.RELEASE/spring-framework-reference/core.html">Version 5.2.22.RELEASE</a> </p><p>💡 IoC 控制反转通常也称为依赖注入（DI）</p><p>Spring 定义依赖来源于：</p><ul><li>构造方法参数</li><li>工厂方法参数</li><li>对象实例化之后通过 setter 设置的属性</li><li>工厂方法返回。</li></ul><p>容器在创建 Bean 时注入这些依赖。</p><p>实际运用中，Bean 通过直接构造类或类似 SPI（ServiceLoader） 的机制来控制依赖的实例化和定位。</p><p><code>BeanFactory</code> 接口提供了一种高级的配置机制，能够管理任何类型的对象。</p><p><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口，增加以下特性：</p><ul><li>更容易集成 Spring AOP 的功能</li><li>消息资源处理（国际化相关）</li><li>事件发布</li><li>特定的应用层上下文，如 <code>WebApplicationContext</code> ，用于 Web 应用程序</li></ul><h1 id="Bean-概览"><a href="#Bean-概览" class="headerlink" title="Bean 概览"></a>Bean 概览</h1><p><code>BeanDefinition</code> 表示 Bean 定义，包含以下：</p><ul><li>包限定的类名：通常是 Bean 的实际实现类</li><li>Bean 行为的配置，在容器的行为（scope，生命周期回调等等）</li><li>引用该 Bean 工作所需的其它 Beans。这些 Beans 引用也称为协作者或依赖项</li><li>属性设置，比如池的大小限制，连接数的管理</li></ul><p><a href="Spring%20IoC%20&%20Beans%20243675ce3e8b4fbfa7532282489f69aa/Bean%20%E5%AE%9A%E4%B9%89%20258186a0b65c43ddb63f1efd23e5e51e.csv">Bean 定义</a></p><h2 id="Bean-命名"><a href="#Bean-命名" class="headerlink" title="Bean 命名"></a>Bean 命名</h2><h2 id="实例化-Beans"><a href="#实例化-Beans" class="headerlink" title="实例化 Beans"></a>实例化 Beans</h2><ul><li>通常，在容器通过反射调用构造函数直接创建 bean 的情况，指定要构造的 bean 类，类似于使用 new 操作符的 Java 代码。</li><li>还有种不常见的情况，指定包含用于创建对象的静态工厂方法的实际类，容器调用类上的静态工厂方法来创建 bean。调用静态工厂方法返回的对象类型可以是相同的类，也可以是完全不同的类。</li></ul><h3 id="通过构造器实例化"><a href="#通过构造器实例化" class="headerlink" title="通过构造器实例化"></a>通过构造器实例化</h3><p>这可能是一种兼容性最好的方法（不需要实现指定的接口或按照某种要求进行编码），只需要指定 bean 类就可以了。但根据 IoC 类型可能需要一个默认（空）构造函数。</p><p>Spring 对 bean 的风格没有要求，可以不是标准的 JavaBeans。比如需要使用一个完全不符合 JavaBeans 规范的传统的连接池，Spring 也能管理它。</p><h3 id="通过静态工厂方法实例化"><a href="#通过静态工厂方法实例化" class="headerlink" title="通过静态工厂方法实例化"></a>通过静态工厂方法实例化</h3><p>通过工厂方法来创建 bean。</p><h3 id="实例工厂方法实例化"><a href="#实例工厂方法实例化" class="headerlink" title="实例工厂方法实例化"></a>实例工厂方法实例化</h3><p>通过工厂 bean 的方法来创建 bean。</p><h1 id="4-依赖"><a href="#4-依赖" class="headerlink" title="4. 依赖"></a>4. 依赖</h1><p>一个应用程序肯定不止由一个对象构成的，即便是最简单的程序，也是由几个对象共同协作来完成目标的。</p><h2 id="4-1-依赖注入"><a href="#4-1-依赖注入" class="headerlink" title="4.1. 依赖注入"></a>4.1. 依赖注入</h2><p>DI 有两种主要的变体</p><ul><li>基于构造器的依赖注入</li><li>基于 Setter 方法的依赖注入</li></ul><h3 id="依赖解析过程"><a href="#依赖解析过程" class="headerlink" title="依赖解析过程"></a>依赖解析过程</h3><h1 id="6-自定义-Bean-的机制"><a href="#6-自定义-Bean-的机制" class="headerlink" title="6. 自定义 Bean 的机制"></a>6. 自定义 Bean 的机制</h1><h2 id="6-1-生命周期回调"><a href="#6-1-生命周期回调" class="headerlink" title="6.1. 生命周期回调"></a>6.1. 生命周期回调</h2><p><strong>初始化 Bean 的回调</strong></p><ul><li><code>@PostConstruct</code></li><li>实现 InitializingBean 重写 <code>afterPropertiesSet()</code></li><li>指定的自定义方法：XML 的 init-method &#x2F; @Bean 注解的 initMethod 属性</li></ul><p><strong>销毁 Bean 的回调</strong></p><ul><li><code>@PreDestroy</code></li><li>实现 DisposableBean 重写 <code>destroy()</code></li><li>指定的自定义方法：XML 的 destroy-method &#x2F; @Bean 注解的 destroyMethod 属性</li></ul><p><strong>组合生命周期机制</strong></p><p>控制 Bean 的生命周期行为有三种选择：</p><ul><li>InitializingBean 和 DisposableBean 回调接口</li><li>自定义 <code>init()</code> 和 <code>destroy()</code> 方法</li><li><code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解</li></ul><p><strong>顺序</strong>：注解 → 回调接口 → 自定义方法</p><p>启动和停止回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.context.Lifecycle<br>org.springframework.context.SmartLifecycle<br>org.springframework.context.support.DefaultLifecycleProcessor<br></code></pre></td></tr></table></figure><h2 id="ApplicationContextAware-and-BeanNameAware"><a href="#ApplicationContextAware-and-BeanNameAware" class="headerlink" title="ApplicationContextAware and BeanNameAware"></a><code>ApplicationContextAware</code> and <code>BeanNameAware</code></h2><h2 id="其它-Aware-接口"><a href="#其它-Aware-接口" class="headerlink" title="其它 Aware 接口"></a>其它 <code>Aware</code> 接口</h2><h1 id="8-容器扩展点"><a href="#8-容器扩展点" class="headerlink" title="8. 容器扩展点"></a>8. 容器扩展点</h1><h2 id="8-1-基于-BeanPostProcessor-自定义-Beans"><a href="#8-1-基于-BeanPostProcessor-自定义-Beans" class="headerlink" title="8.1 基于 BeanPostProcessor 自定义 Beans"></a>8.1 基于 BeanPostProcessor 自定义 Beans</h2><h2 id="8-2-基于-BeanFactoryPostProcessor-自定义配置元信息"><a href="#8-2-基于-BeanFactoryPostProcessor-自定义配置元信息" class="headerlink" title="8.2 基于 BeanFactoryPostProcessor 自定义配置元信息"></a>8.2 基于 BeanFactoryPostProcessor 自定义配置元信息</h2><h2 id="8-3-基于-FactoryBean-自定义实例化逻辑"><a href="#8-3-基于-FactoryBean-自定义实例化逻辑" class="headerlink" title="8.3 基于 FactoryBean 自定义实例化逻辑"></a>8.3 基于 FactoryBean 自定义实例化逻辑</h2><h1 id="9-基于注解的容器配置"><a href="#9-基于注解的容器配置" class="headerlink" title="9. 基于注解的容器配置"></a>9. 基于注解的容器配置</h1><p>💡 基于注解的配置引出一个问题——注解配置是否优于 XML 配置？</p><p>总的来说，注解配置更加简洁，而 XML 配置可以不需要修改源代码或者重新编译代码就能连接组件。<br>而 Spring 兼容这两种配置，所以无需担心，但个人更倾向于注解配置，这也已经变成主流的方式。</p><h2 id="Required"><a href="#Required" class="headerlink" title="@Required"></a>@Required</h2><p>@Required 注解和 RequiredAnnotationBeanPostProcessor 在 Spring 5.1 已经被正式标记废弃，支持用构造方法注入所需的配置 (或 InitializingBean.afterPropertiesSet() 的自定义实现，又或自定义 @PostConstruct 方法).</p><h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h2><ul><li>构造函数</li></ul><p>💡 Spring 4.3 以后，如果目标 Bean 只有一个构造器，则不需要 @Autowired 注解<br>然而，如果 Bean 拥有多个有效构造器且没有主要&#x2F;默认的构造器，则需要使用 @Autowired 注解来告诉容器使用哪个构造函数</p><ul><li><p>Setter 方法</p></li><li><p>字段</p></li><li><p>任意名称、多个参数的方法B</p></li><li><p>数组&#x2F;集合、字段&#x2F;方法上</p><p>  💡 如果希望数组或列表中的项按特定顺序排序，目标 Bean 可以实现 <code>org.springframework.core.Ordered</code> 接口，或者使用 @Order 或标准 @Priority 注解。否则，它们的顺序遵循容器中相应目标 Bean 定义的注册顺序。</p><p>  @Order 影响注入点的优先级，但请注意，这不会影响到单例 Bean 启动的顺序。（启动顺序只由依赖关系和 @Dependson 决定）</p></li></ul><p>可选依赖</p><ul><li>@Autowired(required &#x3D; false)</li><li>java.util.Optional</li><li>@Nullable（JSR-305）</li></ul><p>💡 @Autowired、@Inject、@Value 和 @Resource 注解是由 Spring BeanPostProcessor 实现处理的。这意味着您不能在自己的 BeanPostProcessor 或 BeanFactoryPostProcessor 类型(如果有的话)中应用这些注释。这些类型必须通过使用 XML 或 Spring @Bean 方法显式地“wired up”起来。</p><h2 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h2><p>通常用于注入外部属性</p><h1 id="12-基于-Java-的容器配置"><a href="#12-基于-Java-的容器配置" class="headerlink" title="12. 基于 Java 的容器配置"></a>12. 基于 Java 的容器配置</h1><p>💡 Spring 2.5 支持 XML 和注解的方式进行依赖注入<br>Spring 3.0 后支持无 XML 的纯注解配置（@Configuration）</p><h2 id="基本概念：-Bean-和-Configuration"><a href="#基本概念：-Bean-和-Configuration" class="headerlink" title="基本概念：@Bean 和 @Configuration"></a>基本概念：<code>@Bean</code> 和 <code>@Configuration</code></h2><p>Spring 新的基于 Java 配置支持的核心是 @Configuration 修饰的类和 @Bean 修饰的方法。</p><p>💡 如果 @Bean 没有在 @Configuration 中声明（而是在比如 @Component 或者其他普通类），会被当做 <code>lite</code> 模式处理。在这种情况下，@Bean 是一种通用工厂方法的机制。</p><p><code>lite</code> 的 @Bean 方法不能声明 Bean 之间的依赖关系，没有任何特殊的运行时语义。因此，这种 @Bean 方法不应该调用其它 @Bean 方法。（补充：如果在 lite 模式下调用，本质上是工厂方法生成新实例，而不是从容器获取依赖）</p><p>应尽量使用全 @Configuration 配置，减少不必要的错误。</p><h2 id="通过-AnnotationConfigApplicationContext-实例化-Spring-容器"><a href="#通过-AnnotationConfigApplicationContext-实例化-Spring-容器" class="headerlink" title="通过 AnnotationConfigApplicationContext 实例化 Spring 容器"></a>通过 <code>AnnotationConfigApplicationContext</code> 实例化 Spring 容器</h2><ul><li><p>简单构造器</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);<br><span class="hljs-comment">// 可以是 @Configuration、@Component 以及 JSR-330 注解修饰的类</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(MyServiceImpl.class, Dependency1.class, Dependency2.class);<br></code></pre></td></tr></table></figure></li><li><p><code>register(Class&lt;?&gt;…)</code> 注册方式</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>();<br>ctx.register(AppConfig.class, OtherConfig.class);<br>ctx.register(AdditionalConfig.class);<br></code></pre></td></tr></table></figure></li><li><p>开启组件扫描 <code>scan(String…)</code></p></li><li><p>AnnotationConfigWebApplication 支持 Web 应用</p></li></ul><h2 id="使用-Bean-注解"><a href="#使用-Bean-注解" class="headerlink" title="使用 @Bean 注解"></a>使用 <code>@Bean</code> 注解</h2><p>这是一个方法级别的注解，对标 XML 配置中的 <bean/></p><p>可以用在 @Configuration 或 @Component 的类中。</p><h3 id="Bean-依赖"><a href="#Bean-依赖" class="headerlink" title="Bean 依赖"></a>Bean 依赖</h3><p>带 @Bean 注解的方法可以</p><p>解析机制与构造器依赖注入很相似。</p><h3 id="接受生命周期回调"><a href="#接受生命周期回调" class="headerlink" title="接受生命周期回调"></a>接受生命周期回调</h3><ul><li>@Bean 注解支持常规的生命周期回调——JSR-250 的 <code>@PostConstruct</code> 和 <code>@PreDestroy</code></li><li>常规的 Spring 生命周期回调——实现 <code>InitializingBean</code> ，<code>DisposableBean</code> 或 <code>Lifecycle</code> ，相关方法会被容器回调</li><li>支持标准的 <code>*Aware</code> 接口集合</li><li>@Bean 注解的 <code>initMethod()</code> 和 <code>destroyMethod()</code></li></ul><h2 id="使用-Configuration-注解"><a href="#使用-Configuration-注解" class="headerlink" title="使用 @Configuration 注解"></a>使用 <code>@Configuration</code> 注解</h2><h3 id="注入-inter-bean-依赖"><a href="#注入-inter-bean-依赖" class="headerlink" title="注入 inter-bean 依赖"></a>注入 inter-bean 依赖</h3><p>💡 @Bean 的依赖关系只在 @Configuration 下生效，在 @Component 下无效</p><h3 id="Lookup-方法注入"><a href="#Lookup-方法注入" class="headerlink" title="Lookup 方法注入"></a>Lookup 方法注入</h3><h2 id="编写基于-Java-的配置"><a href="#编写基于-Java-的配置" class="headerlink" title="编写基于 Java 的配置"></a>编写基于 Java 的配置</h2><p>Spring 的基于 Java 配置，通过注解，简化了复杂的配置</p><h3 id="使用-Import-注解"><a href="#使用-Import-注解" class="headerlink" title="使用 @Import 注解"></a>使用 @Import 注解</h3><p>@Import 允许从其它配置类加载 @Bean 定义</p>]]></content>
    
    
    <categories>
      
      <category>分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hystrix 笔记</title>
    <link href="/note-of-hystrix.html"/>
    <url>/note-of-hystrix.html</url>
    
    <content type="html"><![CDATA[<p>💡 为了解决分布式系统的延迟和容错。</p><h1 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h1><p>最新及最稳定的版本定格在了 <code>v1.5.18</code> ，Hystrix 团队把研发重点从预先配置，转移到对应用程序的实时性能做出反应的自适应实现上。官方在已存在的项目里继续使用 Hystrix，在新的内部项目中已经切换到一些更开放及活跃的组件，比如 <a href="https://github.com/resilience4j/resilience4j">resilience4j</a>。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Hystrix 是一个延迟和容错库，旨在隔离远程系统、服务及第三方库的访问点，停止级联故障，并在复杂的分布式系统不可避免的故障中实现弹性。</p><h2 id="Hystrix-能做什么？"><a href="#Hystrix-能做什么？" class="headerlink" title="Hystrix 能做什么？"></a>Hystrix 能做什么？</h2><p>Hystrix 被设计用于：</p><ul><li>为通过第三方客户端访问依赖组件（通常是通过网络）带来的延迟和故障提供保护和控制。</li><li>中断停止复杂分布式系统中的级联故障。</li><li>快速失败和快速恢复。</li><li>在可能的情况下，降级和优雅回退。</li><li>启用接近实时的监控，告警和操作控制。</li></ul><h2 id="Hystrix-解决什么？"><a href="#Hystrix-解决什么？" class="headerlink" title="Hystrix 解决什么？"></a>Hystrix 解决什么？</h2><p>在复杂的分布式架构中应用程序有许多依赖项，每个依赖都有不可避免地出错失败的时刻。如果应用程序没有和外部故障隔离开来，就存在一起宕机的风险。</p><p>举个例子，一个应用依赖 30 个服务，每个服务正常运行时间为 99%，那么：</p><blockquote><p>99.9930 &#x3D; 99.7% uptime<br>0.3% of 1 billion requests &#x3D; 3,000,000 failures<br>2+ hours downtime&#x2F;month even if all dependencies have excellent uptime.<br>这样算下来，即使所有依赖都有优秀的正常运行时间，每个月也会有 2 个多小时的服务不可用</p></blockquote><p>现实情况往往更差。</p><p>即使所有依赖组件都运行良好，但如果不设计好整个系统的弹性，那么数十个服务中每一个服务即使只有 0.01% 的宕机时间，累计影响也相当于一个月潜在的数小时的不可用。</p><hr><p>当一切正常时，请求流如下：</p><p><img src="/note-of-hystrix/Untitled.png"></p><p>当众多后端系统地其中之一发生延迟，它会阻塞整个用户请求：</p><p><img src="/note-of-hystrix/Untitled%201.png" alt="note-of-hystrix%20a1c5e73fea364ddba2bc6e82f0e02e2d/Untitled%201.png"></p><p>对于高流量系统，单个后端依赖的延迟可能会导致所有服务器上的所有资源在几秒钟之内达到饱和。</p><p>应用通过网络或者进入客户端库的每个点，都可能影响到网络请求，这都是潜在故障的来源。</p><p>比故障更可怕的是，备份队列、线程和其它系统资源等等，都可能增加服务之间的延迟，从而造成更多的级联故障。</p><p><img src="/note-of-hystrix/Untitled%202.png" alt="note-of-hystrix%20a1c5e73fea364ddba2bc6e82f0e02e2d/Untitled%202.png"></p><p>当通过第三方客户端执行网络请求时，这些问题会更严重，第三方客户端库是一个”黑盒“，实现细节隐藏在内部，且随时可能会变化，而且每个客户端库的网络或资源配置都不相同，通常很难监控和更改。</p><p>更糟糕的是存在依赖的传递影响，执行的网络调用通常很消耗资源且容易出错，但应用程序没有显式调用。</p><p>网络连接会失败或者降级。服务和服务器会宕机或变慢。新的库或服务部署会改变程序行为或性能。客户端库可能存在 bug。</p><p>所有的这些故障和延迟都需要去隔离和管理，以便单个故障依赖项不会拖垮整个应用或系统。</p><h2 id="Hystrix-有哪些设计原则？"><a href="#Hystrix-有哪些设计原则？" class="headerlink" title="Hystrix 有哪些设计原则？"></a>Hystrix 有哪些设计原则？</h2><ul><li>防止单个依赖项耗尽所有容器（如 Tomcat）的用户线程。</li><li>减少负载、快速失败，而不是使用队列处理。</li><li>情况允许下提供备用方案以保证用户不受故障的影响。</li><li>通过隔离技术（such as bulkhead, swimlane, and circuit breaker patterns）限制任意一个依赖项的影响。</li><li>通过结局实时的统计、监控和告警优化错误发现时间 （time-to-discovery）</li><li>在大部分情况下，Hystrix 借助于配置更改的低延迟传播和对属性动态变更来优化错误恢复时间 （time-to-recovery），好处在于能够使用低延迟反馈循环进行实时操作变更。</li><li>保护依赖客户端的整个执行链路不会失败，而不仅仅是网络流量。</li></ul><h2 id="Hystrix-是如何实现它的目标的？"><a href="#Hystrix-是如何实现它的目标的？" class="headerlink" title="Hystrix 是如何实现它的目标的？"></a>Hystrix 是如何实现它的目标的？</h2><ul><li>将对外部系统（或依赖）的所有调用包装在 HystrixCommand 或 HystrixObservableCommand 对象，这些对象通常在单独的线程中执行。（命令模式）</li><li>超时调用花费的时间超过定义的阈值。有一个默认值，但对于大多数依赖项，您可以通过属性来自定义设置这些超时，以便于略高于每个依赖项所测量的 99.5% 的性能。</li><li>为每个依赖项都维护了一个小的线程池（或信号量）；如果它满了，指向该依赖的请求将立即被拒绝，而不会入队等待。</li><li>衡量成功，失败（由客户端抛出异常），超时和线程拒绝。</li><li>当服务的错误率百分比超过阈值，会在一定时间内手动或自动触发断路器，停止对特定服务的所有请求。</li><li>当请求失败、被拒绝、超时或者短路时，会执行回退逻辑。</li><li>近实时地监控指标和配置变更。</li></ul><p>当使用 Hystrix 包装每个基础依赖，上面图标的服务架构体系会变成下图。每个依赖项相互隔离，在资源有限的情况下，发生延迟服务会变得饱和，覆盖在依赖项何种类型故障响应何种回退的逻辑。</p><p><img src="/note-of-hystrix/Untitled%203.png" alt="note-of-hystrix%20a1c5e73fea364ddba2bc6e82f0e02e2d/Untitled%203.png"></p><h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p>下图展示了当借助于 Hystrix 向服务依赖项发起请求的过程：</p><p><img src="/note-of-hystrix/Untitled%204.png" alt="note-of-hystrix%20a1c5e73fea364ddba2bc6e82f0e02e2d/Untitled%204.png"></p><p>下面展开解释更详细的细节</p><h3 id="1、构造一个-HystrixCommand-或-HystrixObservableCommand-对象"><a href="#1、构造一个-HystrixCommand-或-HystrixObservableCommand-对象" class="headerlink" title="1、构造一个 HystrixCommand 或 HystrixObservableCommand 对象"></a>1、构造一个 <code>HystrixCommand</code> 或 <code>HystrixObservableCommand</code> 对象</h3><p>第一步，构造一个 <code>HystrixCommand</code> 或 <code>HystrixObservableCommand</code> 对象来表示发送给依赖组件的请求。向构造函数传递请求时需要的任何参数。</p><p>如果期望返回一个单一的响应，构造一个 <code>HystrixCommand</code> 对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HystrixCommand</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HystrixCommand</span>(arg1, arg2);<br></code></pre></td></tr></table></figure><p>如果期望返回一个触发响应的可观察者，构造一个 <code>HystrixObservableCommand</code> 对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HystrixObservableCommand</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HystrixObservableCommand</span>(arg1, arg2);<br></code></pre></td></tr></table></figure><h3 id="2、执行-Command"><a href="#2、执行-Command" class="headerlink" title="2、执行 Command"></a>2、执行 Command</h3><p>共有四个方法去执行 Command（前两个只对 <code>HystrixCommand</code> 有效）：</p><ul><li><code>execute()</code> - 阻塞的，返回从依赖组件接收到的单个响应（或在出错时抛异常）</li><li><code>queue()</code> - 返回一个 <code>Future</code> ，可以用它从依赖组件获得单一响应</li><li><code>observe()</code> - 订阅表示响应的 <code>Observable</code> ，返回源 <code>Observable</code> 的复制。</li><li><code>toObservable()</code> - 返回一个 <code>Observable</code> ，当订阅它时，会执行 Hystrix command 并触发响应</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">K</span>             <span class="hljs-variable">value</span>   <span class="hljs-operator">=</span> command.execute();<br>Future&lt;K&gt;     fValue  = command.queue();<br>Observable&lt;K&gt; ohValue = command.observe();         <span class="hljs-comment">//hot observable</span><br>Observable&lt;K&gt; ocValue = command.toObservable();    <span class="hljs-comment">//cold observable</span><br></code></pre></td></tr></table></figure><p>同步方法 <code>execute()</code> 实则调用 <code>queue().get()</code> 。</p><p>而 <code>queue()</code> 则是调用 <code>toObeservable().toBlocking().toFuture()</code> 。</p><p>也就是说，包括返回单个简单值的方法，所有 <code>HystrixCommand</code> 都由 <code>Observable</code> 实现支持的。 </p><h3 id="3、响应是否被缓存？"><a href="#3、响应是否被缓存？" class="headerlink" title="3、响应是否被缓存？"></a>3、响应是否被缓存？</h3><p>如果 command 对象开启了请求缓存，并且该请求的响应在缓存中仍有效，缓存的响应则会立刻返回到 Observable 的表单中。</p><h3 id="4、断路器是否开启？"><a href="#4、断路器是否开启？" class="headerlink" title="4、断路器是否开启？"></a>4、断路器是否开启？</h3><p>当 command 被执行，Hystrix 会检查断路器是否打开状态。</p><p>如果“电路”是打开状态（或称为”跳闸“），Hystrix 将不会执行 command，并将流程路由到（8）执行回退（降级）。</p><p>如果”电路“是关闭状态的，流程会继续推进到（5），查看是否有可用的容量去执行 command。</p><h3 id="5、Thread-Pool-x2F-Queue-x2F-Semaphore-满了吗？"><a href="#5、Thread-Pool-x2F-Queue-x2F-Semaphore-满了吗？" class="headerlink" title="5、Thread Pool&#x2F;Queue&#x2F;Semaphore 满了吗？"></a>5、Thread Pool&#x2F;Queue&#x2F;Semaphore 满了吗？</h3><p>如果与 command 关联的 thread-pool 和 queue（或是 semaphore，不在 thread 运行时）满了，那么 Hystrix 将不会执行 command 并且立即将流程路由到（8）执行回退（降级）。</p><h3 id="6、HystrixObservableCommand-construct-or-HystrixCommand-run"><a href="#6、HystrixObservableCommand-construct-or-HystrixCommand-run" class="headerlink" title="6、HystrixObservableCommand.construct() or HystrixCommand.run()"></a>6、<code>HystrixObservableCommand.construct()</code> or <code>HystrixCommand.run()</code></h3><p>在这里，Hystrix 通过为此目的编写的方法调用对依赖项的请求，方法如下：</p><ul><li><code>HystrixCommand.run()</code> - 返回一个单一响应或抛出一个异常</li><li><code>HystrixObservableCommand.construct()</code> — 返回一个能够触发响应的 Observable 或发送一个 <code>onError</code> 通知</li></ul><p>如果 <code>run()</code> 或 <code>construct()</code> 方法超出 command 的超时时间，线程将会抛出一个 <code>TimeoutException</code> （或者在单独的计时器线程抛出异常，如果 command 不在自己的 thread 中运行）。这种情况下，Hystrix 将路由到降级（8），如果方法没有被取消或中断，将丢弃 <code>run()</code> 或 <code>construct()</code> 的最终返回值。</p><p>Hystrix 在 JVM 能够做到最好的就是抛出一个 <code>InterrupedException()</code>，但请注意，这并不能强行让潜在的线程停止工作。如果 Hystrix 包装的任务线程没有遵循中断异常，那么尽管客户端以及收到一个 <code>TimeoutException</code>， Hystrix 线程池的线程仍将继续它的工作。这种行为可能会使 Hystrix 线程池饱和，尽管负载被”正确地释放“。大多数 Java HTTP 客户端库都不遵循中断异常。所以确保在 HTTP 客户端上正确配置连接和读写的超时时间。</p><p>如果 command 没有抛出任何异常，并且返回了一个响应，那么 Hystrix 将在执行一些日志记录和度量报告后返回该响应。<code>run()</code> 方法，Hystrix 会返回一个 Observable 单一的响应，然后触发 <code>onCompleted()</code> 通知；而 <code>construct()</code> 同样返回一个相同的 Observable 对象。</p><h3 id="7、计算执行链路的健康"><a href="#7、计算执行链路的健康" class="headerlink" title="7、计算执行链路的健康"></a>7、计算执行链路的健康</h3><p>Hystrix 向熔断器报告成功，失败，请求被拒绝和请求超时，维护了一组用于计算统计信息的滚动的计数器。</p><p>它使用这些统计数据来确定”电路“什么时候”跳闸“，将短路所有后续的请求，直到恢复周期结束。结束后，它将在首次检查一定的健康检查项后再次关闭（熔断结束，重新连通）“电路”。</p><h3 id="8、降级方案"><a href="#8、降级方案" class="headerlink" title="8、降级方案"></a>8、降级方案</h3><p>每当 command 执行失败时，Hystrix 尝试恢复到降级计划：</p><ul><li>当 <code>construct()</code> 或 <code>run()</code>  抛出异常（6）</li><li>当 command 因链路断开而短路时（4）</li><li>当 command 的线程池和队列或信号量容量已满时（5）</li><li>当 command 执行超时</li></ul><p>你可以编写自己的降级方案用于提供通用的响应，来自内存缓存或者通过静态逻辑，从而不需要依赖网络。如果想在降级方案中使用到网络调用，应该通过另一个 <code>HystrixCommand</code> 或 <code>HystrixObservableCommand</code> 来实现。</p><p><code>HystrixCommand</code>  - 实现 <code>HystrixCommand.getFallback()</code> </p><p><code>HystrixObservableCommand</code>  - 实现 <code>HystrixObservableCommand.resumeWithFallback()</code></p><p>上述两个方法会返回 Observable 对象。</p><p>如果你没有实现降级方法，或者降级方法本身抛出异常，Hystrix 仍然会返回 Observable 对象，但该对象不会携带任何信息并且会立即以 <code>onError</code> 通知终止。正是通过这个 <code>onError</code> 通知，导致命令失败的异常得以传回给调用者。（实现一个可能会异常的降级方法是很糟糕的实践。你应该实现的降级，不应该执行任何可能失败的逻辑。）</p><p>降级失败或不存在降级策略的最终结果将根据调用 Hystrix command 的方式而各不相同：</p><ul><li><code>execute()</code> - 抛出异常</li><li><code>queue()</code> - 能够正常返回一个 Future 对象，但是如果调用其 <code>get()</code> 方法，将会抛异常</li><li><code>observe()</code> - 返回一个 <code>Observable</code> 对象，当订阅该对象时，它会通过调用订阅者的 <code>onError</code> 方法立即终止</li><li><code>toObservable()</code> - 返回一个 <code>Observable</code> 对象，当订阅该对象时，它会通过调用订阅者的 <code>onError</code> 方法终止</li></ul><h3 id="9、返回成功的响应"><a href="#9、返回成功的响应" class="headerlink" title="9、返回成功的响应"></a>9、返回成功的响应</h3><ul><li><code>execute()</code> — obtains a <code>Future</code> in the same manner as does <code>.queue()</code> and then calls <code>get()</code> on this <code>Future</code> to obtain the single value emitted by the <code>Observable</code></li><li><code>queue()</code> — 把 <code>Observable</code> 放到 <code>BlockingObservable</code> 以便于能够将其转换成 <code>Future</code>, 然后返回这个 <code>Future</code></li><li><code>observe()</code> — subscribes to the <code>Observable</code> immediately and begins the flow that executes the command; returns an <code>Observable</code> that, when you <code>subscribe</code> to it, replays the emissions and notifications</li><li><code>toObservable()</code> — returns the <code>Observable</code> unchanged; you must <code>subscribe</code> to it in order to actually begin the flow that leads to the execution of the command</li></ul><h2 id="熔断器"><a href="#熔断器" class="headerlink" title="熔断器"></a>熔断器</h2><p>下图展示了 <code>Hystrix</code> 或 <code>HystrixObservableCommand</code> 与 <code>HystrixCircuitBreaker</code> 的交互逻辑以及决策判定，包括计数器的行为。</p><p><img src="/note-of-hystrix/Untitled%205.png" alt="note-of-hystrix%20a1c5e73fea364ddba2bc6e82f0e02e2d/Untitled%205.png"></p><p>电路的开合准确的区分方法如下：</p><ol><li><p>假设通过电路的电量满足一定的阈值</p><p> <code>HystrixCommandProperties.circuitBreakerRequestVolumeThreshold()</code></p></li><li><p>假设错误率超过错误率的阈值</p><p> <code>HystrixCommandProperties.circuitBreakerErrorThresholdPercentage()</code></p></li><li><p>熔断器从 <code>CLOSED</code> 转换成 <code>OPEN</code> </p></li><li><p>一段时间之后，下一个请求被允许通过（当前为 <code>HALF-OPEN</code> 状态）。如果请求失败，熔断器在休眠窗口期间返回 <code>OPEN</code> 状态。如果请求成功，熔断器转换为 <code>CLOSED</code> 状态，回到第 <strong>1</strong> 步。如此反复。</p></li></ol><h2 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h2><p>Hystrix 使用隔板模式来隔离组件彼此之间的依赖关系，并限制对任一组件的并发访问。</p><p><img src="/note-of-hystrix/Untitled%206.png" alt="note-of-hystrix%20a1c5e73fea364ddba2bc6e82f0e02e2d/Untitled%206.png"></p><h2 id="线程-amp-线程池"><a href="#线程-amp-线程池" class="headerlink" title="线程 &amp; 线程池"></a>线程 &amp; 线程池</h2><p>客户端（库，网络调用等）在运行在单独的线程中。这将它们与调用线程（Tomcat 线程池）隔离开，以便调用方能够“离开”耗时长的依赖项调用。</p><p>Hystrix 使用独立的线程池来约束给定的依赖项，所以底层执行的延迟只会让线程池的可用线程饱和。</p><p><img src="/note-of-hystrix/Untitled%207.png" alt="note-of-hystrix%20a1c5e73fea364ddba2bc6e82f0e02e2d/Untitled%207.png"></p><p>你也可以在不使用线程池的情况下避免失败，但这要求受信任的客户端必须非常迅速地失败（网络连接&#x2F;读超时和重试配置）且总是运转地很好。</p><p>Netflix 在 Hystrix 的设计中，出于许多原因选择使用线程和线程池来实现隔离，如下：</p><ul><li>许多应用程序执行若干（有时超过 100）的由不同开发团队开发的后端服务</li><li>每个服务都提供其自己的客户端库</li><li>客户端库一直在变化</li><li>客户端库逻辑可能增加新的网络调用</li><li>客户端库可能包含重试，数据解析，缓存（内存或网络）等逻辑，以及其它类似行为</li><li>客户端库像个”黑盒“——屏蔽实现</li><li>在几个现实的生产中断案例中检测出”噢，有些东西改变了，属性应该被调整“或”客户端库改变了它的行为“</li><li>即使客户端本身没有变化，服务本身也会发生变化，会影响到性能，从而导致客户端配置无效</li><li>传递依赖关系可能引入其它的客户端库，这些库可能不是预期的，也可能没有正确地配置</li><li>大多数网络访问都是同步执行的</li><li>故障和延迟也由可能发生在客户端代码中，而不仅仅是网络调用</li></ul><p><img src="/note-of-hystrix/Untitled%208.png" alt="note-of-hystrix%20a1c5e73fea364ddba2bc6e82f0e02e2d/Untitled%208.png"></p><h3 id="线程池的优势"><a href="#线程池的优势" class="headerlink" title="线程池的优势"></a>线程池的优势</h3><p>通过依赖项各自线程池的线程实现隔离的优势有：</p><ul><li>应用程序完全不受失控客户端库的影响。给定依赖项的线程池饱和，也不会影响应用程序的其余部分。</li><li>应用接入新的客户端库会少很多风险。如果有问题，隔离了该客户端库也不会影响到其它部分。</li><li>当故障的客户端重新恢复正常时，线程池将被清除，应用程序立即恢复正常的性能，而不是在整个 Tomcat 容器过载时进行长时间恢复。</li><li>如果客户端库配置有误，通过线程池的运行状况能很快地推断证明出来（通过增加地错误，延迟，超时，拒绝等等）且可以再不影响应用功能地情况下处理它（通常通过动态属性实时处理）。</li><li>如果客户端服务改变性能特征（通常会出现问题），又需要进行调优（增加&#x2F;减少超时时间，重试等等），而这可以通过线程池的指标进行可视化监控（错误，延迟，超时，拒绝），能够在不影响其他客户端，请求或用户的情况下处理。</li><li>除了隔离的好处之外，专用线程池还能提供了内置的并发性，可以利用它在同步客户端库之上构建异步接口 facade（类似于 Netflix API 如何在 Hystrix command 上构建响应式、完全异步的Java API）</li></ul><p>简而言之，线程池提供的隔离允许优雅地处理不断变化的客户端库和子系统性能特征的动态组合，而不会导致宕机。</p><p><strong>注意</strong>：尽管单独的线程提供了隔离，但你的底层客户端库也应该有超时和&#x2F;或响应线程中断，保证它不会无限期地阻塞，导致 Hystrix 线程池饱和。</p><h3 id="线程池的缺点"><a href="#线程池的缺点" class="headerlink" title="线程池的缺点"></a>线程池的缺点</h3><p>最主要的缺点就是增加了计算的开销。每个 command 执行都在单独的线程运行，其中涉及队列、调度和上下文切换。</p><p>Netflix 在设计这一系统时，认为开销足够小，不会对成本或性能产生重大影响。决定接受这种开销的成本，以换取它提供的好处。</p><h3 id="线程开销"><a href="#线程开销" class="headerlink" title="线程开销"></a>线程开销</h3><h3 id="Semaphores"><a href="#Semaphores" class="headerlink" title="Semaphores"></a>Semaphores</h3><p>你也可以使用信号量（或计数器）来限制任何指定依赖的并发调用次数，而不使用线程池&#x2F;队列。这可以让 Hystrix 在不使用线程池的情况下卸载负载，但不允许超时和推出。如果你信任客户端并且希望减轻负载，那么可以使用这种方法。</p><p><code>HystrixCommand</code> 和 <code>HystrixObservableCommand</code> 在 2 点支持信号量：</p><ul><li><strong>Fallback</strong>：Hystrix 通常在 Tomcat 调用线程上恢复降级。</li><li><strong>Execution</strong>：如果你设置 <code>execution.isolation.strategy</code> 属性为 <code>SEMAPHORE</code> ，Hystrix 会使用 semaphores 去限制调用 command 的并发线程数。</li></ul><h2 id="请求折叠（合并）"><a href="#请求折叠（合并）" class="headerlink" title="请求折叠（合并）"></a>请求折叠（合并）</h2><p>下图展示了两种情况下的线程数和网络连接数：第一种没用折叠请求，第二种用了（假设所有连接都是在短时间内并发的，在本例中是 10ms）。</p><p><img src="/note-of-hystrix/Untitled%209.png" alt="note-of-hystrix%20a1c5e73fea364ddba2bc6e82f0e02e2d/Untitled%209.png"></p><h3 id="为什么需要请求折叠？"><a href="#为什么需要请求折叠？" class="headerlink" title="为什么需要请求折叠？"></a>为什么需要请求折叠？</h3><p><strong>全局上下文（跨越所有 Tomcat 线程）</strong></p><p>全局的应用级别是最理想的，能够将任意 Tomcat 线程上的任意用户请求合并到一起。</p><p><strong>用户请求上下文（单一的 Tomcat 线程）</strong></p><h2 id="请求缓存"><a href="#请求缓存" class="headerlink" title="请求缓存"></a>请求缓存</h2><p><img src="/note-of-hystrix/Untitled%2010.png" alt="note-of-hystrix%20a1c5e73fea364ddba2bc6e82f0e02e2d/Untitled%2010.png"></p><p>请求缓存的好处：</p><p>- </p><h1 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h1><p>对于大多数操作都希望有降级策略，但总有几个例外：</p><ol><li><p>执行写操作的命令</p><p> 如果写入失败，更可能希望将失败返回给调用方。</p></li><li><p>批量的系统&#x2F;离线计算</p><p> 当填充缓存、生成报告或是任何形式的离线计算，更合适的做法通常是将错误返回给调用方，以便稍后重试，而不是发送一个静默的降级响应。</p></li></ol><h1 id="Error-Propagation"><a href="#Error-Propagation" class="headerlink" title="Error Propagation"></a>Error Propagation</h1>]]></content>
    
    
    <categories>
      
      <category>Hystrix</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hystrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebSocket笔记</title>
    <link href="/note-of-websocket.html"/>
    <url>/note-of-websocket.html</url>
    
    <content type="html"><![CDATA[<h1 id="spring-websocket-总览"><a href="#spring-websocket-总览" class="headerlink" title="spring-websocket 总览"></a>spring-websocket 总览</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">└── web<br>   └── socket<br>      ├── adapter #适配 Spring WebSocket 对 Java 标准 WebSocket API 适配（还有 Jetty 标准实现）包括有编解码、相互扩展、处理器、Session<br>      ├── client #客户端  Spring 对 WebSocket 客户端以及 Java 标准 WebSocket endpoints 实现<br>      ├── config #对 WebSocket 请求处理的配置（xml 配置和基于注解的配置支持）<br>      ├── handler #针对 WebSocketHandler 的实现和装饰<br>      ├── messaging #WebSocket 集成 Spring messaging <br>      ├── server #WebSocket 交互的服务端抽象<br>      ├── sockjs #Top-level SockJS types.<br>      ├── AbstractWebSocketMessage.java #抽象消息<br>      ├── BinaryMessage.java  #二进制消息<br>      ├── CloseStatus.java #WebSocket 关闭状态码和原因<br>      ├── <span class="hljs-keyword">package</span>-info.java <br>      ├── PingMessage.java<br>      ├── PongMessage.java <br>      ├── SubProtocolCapable.java #WebSocket 标准中定义的 WebSocket 处理器子协议接口<br>      ├── TextMessage.java #文本消息<br>      ├── WebSocketExtension.java #扩展<br>      ├── WebSocketHandler.java #WebSocket 消息和生命周期事件处理器（ExceptionWebSocketHandlerDecorator 提供异常处理策略）<br>      ├── WebSocketHttpHeaders.java #增加了 WebSocket 规范的 http 头<br>      ├── WebSocketMessage.java #消息顶级接口<br>      └── WebSocketSession.java #WebSocket session 顶级接口<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_38345296/article/details/104040612">WebSocket实战详解【Springboot+Vue+sockjs+webstomp】_Slience Wind-CSDN博客</a></p><p><a href="https://blog.csdn.net/u011943534/article/details/97098687">springboot学习(二十一) springboot中websocket使用@MessageMapping接收各种类型数据_文若书生的专栏-CSDN博客</a></p><p><a href="https://blog.csdn.net/elonpage/article/details/78446695?locationNum=5&fps=1">Spring+STOMP实现WebSocket广播订阅、权限认证、一对一通讯（附源码）_杰明Jamin的博客-CSDN博客</a></p><p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web.html#websocket-stomp">Web on Servlet Stack</a></p><p><a href="http://www.mydlq.club/article/86/">SpringBoot 实现 Websocket 通信详解</a></p><h1 id="身份认证及鉴权"><a href="#身份认证及鉴权" class="headerlink" title="身份认证及鉴权"></a>身份认证及鉴权</h1><ul><li>握手鉴权（通过 Session）</li><li>首次发送消息拦截（通过 WebSocket &#x2F; Stomp 连接方法携带 header）</li></ul><p><img src="/note-of-websocket/Untitled.png" alt="note-of-websocket%2029723de254c64768a5242417d6575173/Untitled.png"></p><ol><li>登录（Session）</li><li>WebSocket 连接（关联 Session）</li><li>后续业务<ul><li>判断用户是否在线</li><li>推送</li></ul></li></ol><p>潜在问题：</p><ol><li>连接中断（快速的恢复连接）</li><li>发送消息失败（考虑下次重连发送 Redis）</li></ol><h1 id="https-与-wss"><a href="#https-与-wss" class="headerlink" title="https 与 wss"></a>https 与 wss</h1><p><a href="https://www.cnblogs.com/mafly/p/websocket.html">WebSocket 结合 Nginx 实现域名及 WSS 协议访问</a></p><p><a href="https://docs.mattermost.com/install/troubleshooting.html#failed-to-upgrade-websocket-connection">Important Notes - Mattermost 5.28 documentation</a></p><h1 id="4-Spring-Doc（WebSocket-部分）"><a href="#4-Spring-Doc（WebSocket-部分）" class="headerlink" title="4. Spring Doc（WebSocket 部分）"></a>4. Spring Doc（WebSocket 部分）</h1><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket">Web on Servlet Stack</a></p><h2 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1. 介绍"></a>4.1. 介绍</h2><p><a href="https://tools.ietf.org/html/rfc6455">RFC 6455 - The WebSocket Protocol</a></p><p>The WebSocket protocol, RFC 6455, provides a standardized way to establish a full-duplex, two-way communication channel between client and server over a single TCP connection.</p><h3 id="4-1-1-Http-VS-WebSocket"><a href="#4-1-1-Http-VS-WebSocket" class="headerlink" title="4.1.1. Http VS WebSocket"></a>4.1.1. Http VS WebSocket</h3><p>尽管 WebSocket 被设计成兼容 HTTP 并始于 HTTP 请求，但这两种协议会导致非常不同的体系结构和编程模型，理解这一点很重要。</p><p>在 HTTP 和 REST 中，应用的建模基于众多的 URL。客户端以「请求-响应」的方式访问那些 URL，从而与应用服务进行交互。服务端根据 HTTP URL、method 和 headers 来将请求路由到正确的处理器。</p><p>相比之下，通常只有一个用于初始化连接的 URL 在 WebSocket 中。随后，所有的应用消息都在同一 TCP 连接之上传输。这就指向了一个完全不一样的异步的、事件驱动的消息传递体系结构。</p><p>与 HTTP 不同的是，WebSocket 是一种低级传输协议。它不规定消息内容的任何语义。这意味着，除非客户端和服务端在消息语义上达成一致，否则无法路由或者处理消息。</p><p>通过 HTTP 握手请求的 <code>Sec-WebSocket-Protocol</code> 请求头，WebSocket 客户端和服务端可以协商使用更高级的消息传递协议（比如说 STOMP）。这种情况下，需要限定他们自己的规范。</p><h3 id="4-1-2-什么时候应该使用-WebSocket"><a href="#4-1-2-什么时候应该使用-WebSocket" class="headerlink" title="4.1.2. 什么时候应该使用 WebSocket"></a>4.1.2. 什么时候应该使用 WebSocket</h3><p>WebSocket 旨在使得网页是动态和交互的。然而，一般情况下，Ajax &amp; HTTP 和长轮询就能够提供简单有效的解决方案。</p><p>举个例子，类似新闻、邮件和社交流需要动态更新，但是几分钟更新一次是可以被接受的。而在协同、游戏和金融应用中，更新的频率需要接近实时。</p><p>It is the combination of low latency, high frequency, and high volume that make the best case for the use of WebSocket.</p><p>低时延，高频率和高容量的组合即是使用 WebSocket 的最佳场景。</p><p>还需要注意的是，在你控制之外的限制性代理可能会阻止 WebSocket 交互，要么因为他们没有设置 <code>Upgrade</code>请求头，要么因为他们关闭长时间空闲的连接。This means that the use of WebSocket for internal applications within the firewall is a more straightforward decision than it is for public facing applications.（不太好翻译，大概就是说防火墙内的内部应用使用 WebSocket 的成本更低）</p><h2 id="4-2-WebSocket-API"><a href="#4-2-WebSocket-API" class="headerlink" title="4.2. WebSocket API"></a>4.2. WebSocket API</h2><p>The Spring Framework provides a WebSocket API that you can use to write client- and server-side applications that handle WebSocket messages.</p><h3 id="4-2-1-WebSocketHandler"><a href="#4-2-1-WebSocketHandler" class="headerlink" title="4.2.1. WebSocketHandler"></a>4.2.1. WebSocketHandler</h3><p><img src="/note-of-websocket/Untitled%201.png" alt="note-of-websocket%2029723de254c64768a5242417d6575173/Untitled%201.png"></p><p>Spring WebSocket 模块不基于 Spring MVC。通过 <code>WebSocketHttpRequestHandler</code> ，将 <code>WebSocketHandler</code> 集成到其它 HTTP 服务环境相对简单。</p><p> 当直接或者间接使用 <code>WebSocketHandler</code> API 时（例如通过 STOMP 消息传递），应用必须同步发送消息，因为底层标准 WebSocket Session（JSR-356）不允许并发发送。一种可选方案是用 <code>ConcurrentWebSocketSessionDecorator</code>来包装 <code>WebSocketSession</code> 。</p><h3 id="4-2-2-WebSocket-握手"><a href="#4-2-2-WebSocket-握手" class="headerlink" title="4.2.2. WebSocket 握手"></a>4.2.2. WebSocket 握手</h3><aside>💡 Spring 提供了 `WebSocketHandlerDecorator`  基类来用附加行为装饰 `WebSocketHandler` 。默认 Java 配置或 XML 配置下，日志和异常处理提供默认实现。`ExceptionWebSocketHandlerDecorator` 捕获来自任何 `WebSocketHandler` 方法的所有未捕获异常，并以状态`1011` 关闭WebSocket会话，这表示一个服务器错误。</aside><h3 id="4-2-3-Deployment"><a href="#4-2-3-Deployment" class="headerlink" title="4.2.3. Deployment"></a>4.2.3. Deployment</h3><ul><li><input disabled="" type="checkbox"> TODO</li></ul><h3 id="4-2-4-Server-Configuration-服务端配置"><a href="#4-2-4-Server-Configuration-服务端配置" class="headerlink" title="4.2.4. Server Configuration 服务端配置"></a>4.2.4. Server Configuration 服务端配置</h3><p>每个底层 WebSocket 引擎都开放了供控制运行时特性的配置属性，比如消息缓冲区大小、空闲超时时间等等。</p><p>对于 Tomcat 等容器（除 Jetty），你可以注入 <code>ServletServerContainerFactoryBean</code> 到你的配置类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSocket</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebSocketConfigurer</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ServletServerContainerFactoryBean <span class="hljs-title function_">createWebSocketContainer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ServletServerContainerFactoryBean</span> <span class="hljs-variable">container</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletServerContainerFactoryBean</span>();<br>        container.setMaxTextMessageBufferSize(<span class="hljs-number">8192</span>);<br>        container.setMaxBinaryMessageBufferSize(<span class="hljs-number">8192</span>);<br>        <span class="hljs-keyword">return</span> container;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 Jetty，则需要提供一个预配置的握手处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> DefaultHandshakeHandler <span class="hljs-title function_">handshakeHandler</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">WebSocketPolicy</span> <span class="hljs-variable">policy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketPolicy</span>(WebSocketBehavior.SERVER);<br>    policy.setInputBufferSize(<span class="hljs-number">8192</span>);<br>    policy.setIdleTimeout(<span class="hljs-number">600000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultHandshakeHandler</span>(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">JettyRequestUpgradeStrategy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketServerFactory</span>(policy)));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-5-Allowed-Origins"><a href="#4-2-5-Allowed-Origins" class="headerlink" title="4.2.5. Allowed Origins"></a>4.2.5. Allowed Origins</h3><p>默认只支持同源请求，也可以自定义配置。</p><p>（Nothing prevents other types of clients from modifying the Origin header value）</p><p>有 3 种可能的情况：</p><ol><li><p>只允许同源请求（默认配置下）</p><p> In this mode, when SockJS is enabled, the Iframe HTTP response header X-Frame-Options is set to SAMEORIGIN, and JSONP transport is disabled, since it does not allow checking the origin of a request. As a consequence, IE6 and IE7 are not supported when this mode is enabled.</p></li><li><p>指定的 origins 列表</p><p> Each allowed origin must start with http:&#x2F;&#x2F; or https:&#x2F;&#x2F;. In this mode, when SockJS is enabled, IFrame transport is disabled. As a consequence, IE6 through IE9 are not supported when this mode is enabled.</p></li><li><p>允许所有 origins（这种情况下，所有传输都有效，应该是推荐这种配置）</p><p> To enable this mode, you should provide * as the allowed origin value. In this mode, all transports are available.</p></li></ol><h2 id="4-3-SockJS-Fallback（回退）"><a href="#4-3-SockJS-Fallback（回退）" class="headerlink" title="4.3. SockJS Fallback（回退）"></a>4.3. SockJS Fallback（回退）</h2><p>公网上，限制性代理可能会阻止 WebSocket 交互。（可能没有配置 <code>Upgrade</code> 头升级协议，可能长时间空闲被关闭连接）</p><p>解决上述问题的方案就是 WebSocket 模拟：先尝试使用 WebSocket，（不成功）再尝试使用基于 HTTP 的技术来模拟 WebSocket 的交互，同时暴露相对应的应用级别的 API。</p><h3 id="4-3-1-总览"><a href="#4-3-1-总览" class="headerlink" title="4.3.1. 总览"></a>4.3.1. 总览</h3><p>SockJS 的目的是让应用再运行时使用 WebSocket API，必要时退回非 WebSocket的模式，而不需要修改应用代码。</p><p>本章 SockJS 由以下组成：</p><ul><li>SockJS 协议 <a href="https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html">https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html</a></li><li>SockJS JavaScript 客户端 —— 浏览器端的客户端库</li><li>SockJS 服务端实现，例如 <code>spring-websocket</code></li><li>SockJS Java 客户端（包含在 <code>spring-websocket</code> )</li></ul><p>SockJS 为浏览器设计。传输可以分为 3 类：</p><ol><li>WebSocket</li><li>HTTP Streaming（我理解为 ajax？</li><li>HTTP Long Polling（长轮询</li></ol><p>具体参考下文</p><p><a href="https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/">Spring MVC 3.2 Preview: Techniques for Real-time Updates</a></p><p>SockJS 客户端发送 GET 请求 <code>/info</code> 从服务端获取基本信息，从而决定使用哪一种传输方式。</p><p>WebSocket → HTTP streaming → HTTP（long）polling</p><p>所有传输请求都具有以下 URL 结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">https://host:port/myApp/myEndpoint/&#123;server-id&#125;/&#123;session-id&#125;/&#123;transport&#125;<br></code></pre></td></tr></table></figure><ul><li><code>&#123;server-id&#125;</code> 对于集群中的路由请求十分有用。</li><li><code>&#123;session-id&#125;</code> 将属于 SockJS 会话的 HTTP 请求关联起来。</li><li><code>&#123;transport&#125;</code> 表示传输方式 (例如, <code>websocket</code>, <code>xhr-streaming</code> 等).</li></ul><p>WebSocket 传输只需要一次 HTTP 请求来做 WebSocket 握手，之后所有消息传输交换都在该连接（socket）上。</p><p>SockJS adds minimal message framing.（最小消息帧）</p><p><code>o</code> open frame</p><p><code>h</code> heartbeat frame</p><p><code>c</code> close frame</p><h3 id="4-3-2-开启-SockJS"><a href="#4-3-2-开启-SockJS" class="headerlink" title="4.3.2. 开启 SockJS"></a>4.3.2. 开启 SockJS</h3><p>通过配置类开启 <code>withSockJS()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSocket</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebSocketConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerWebSocketHandlers</span><span class="hljs-params">(WebSocketHandlerRegistry registry)</span> &#123;<br>        registry.addHandler(myHandler(), <span class="hljs-string">&quot;/myHandler&quot;</span>).withSockJS();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>sockjs-client</code> 取决于浏览器</p><p><a href="https://github.com/sockjs/sockjs-client/">sockjs&#x2F;sockjs-client</a></p><h3 id="4-3-3-IE-8-and-9"><a href="#4-3-3-IE-8-and-9" class="headerlink" title="4.3.3. IE 8 and 9"></a>4.3.3. IE 8 and 9</h3><ul><li><input disabled="" type="checkbox"> TODO</li></ul><h3 id="4-3-4-Heartbeats"><a href="#4-3-4-Heartbeats" class="headerlink" title="4.3.4. Heartbeats"></a>4.3.4. Heartbeats</h3><p>SockJS 协议要求服务端发送心跳信息来防止代理判定连接挂起。</p><p>Spring SockJS 配置中有一个叫 <code>heartbeatTime</code> 的属性，可以自定义频率。默认情况下，如果连接上没有发送其他消息，将会在 25 秒后发送心跳。25 秒这个值符合 IETF 的建议。</p><p>💡 当在 WebSocket 和 SockJS 之上使用 STOMP时，如果 STOMP 客户端和服务端协商交换心跳，SockJS 的心跳将被禁用。</p><p>Spring SockJS 支持还允许您配置 <code>TaskScheduler</code> 来调度心跳任务。</p><p>任务调度器由线程池支持，其默认设置基于可用处理器的数量。您应该考虑根据您的具体需要自定义设置。</p><h3 id="4-3-5-Client-Disconnects"><a href="#4-3-5-Client-Disconnects" class="headerlink" title="4.3.5. Client Disconnects"></a>4.3.5. Client Disconnects</h3><p>在 Servlet 容器中，这是通过 Servlet 3 异步支持完成的，该支持允许退出Servlet容器线程，处理请求，并继续写入来自另一个线程的响应。</p><p>一个特定常见的问题是，Servlet API 不会通知客户端断开了连接。但是，Servlet 容器会在断开后写 response 时发生异常。由于 Spring s SockJS 服务支持服务器发送心跳（默认为每 25 秒），这意味着客户端断开连接通常在该时间段内被检测到（或者更早，如果消息发送更频繁的话）。</p><p>💡 因此，网络 I&#x2F;O 可能会因为客户端断开连接而发生错误，把无用的 stack traces 写入日志。Spring 尽最大努力识别表示客户端断开连接（特定于每个服务器）的网络故障，并通过使用专用的日志类别——断开连接的客户端日志类别（在 AbstractSockJsSession 中定义）记录最小的消息作为日志。If you need to see the stack traces, you can set that log category to TRACE.</p><h3 id="4-3-6-SockJS-and-CORS（跨域）"><a href="#4-3-6-SockJS-and-CORS（跨域）" class="headerlink" title="4.3.6. SockJS and CORS（跨域）"></a>4.3.6. SockJS and CORS（跨域）</h3><ul><li><input disabled="" type="checkbox"> TODO</li></ul><h3 id="4-3-7-SockJSClient"><a href="#4-3-7-SockJSClient" class="headerlink" title="4.3.7. SockJSClient"></a>4.3.7. SockJSClient</h3><p>Spring 提供了一个 SockJS Java 客户端来连接远程的 SockJS 端点，从而不需要使用浏览器。当需要在公共网络上（网络代理可能阻止 WebSocket 协议）的两台服务器之间进行双向通信时，这尤其有用。SockJS 的 Java 客户端也非常适用于测试场景（例如，模拟大量并发用户）。</p><ul><li><input disabled="" type="checkbox"> TODO</li></ul><h2 id="4-4-STOMP"><a href="#4-4-STOMP" class="headerlink" title="4.4. STOMP"></a>4.4. STOMP</h2><p>WebSocket 协议定义两种类型的消息（文本和二进制），但内容没有规范定义。</p><p>使用 STOMP 子协议是可选操作，因为无论采用哪种方式，客户端和服务端都需要达成一致。</p><h3 id="4-4-1-总览"><a href="#4-4-1-总览" class="headerlink" title="4.4.1. 总览"></a>4.4.1. 总览</h3><p>STOMP（Simple Text Oriented Protocol 简单的面向文本的消息传递协议）最初是为脚本语言创建，用于连接到企业消息代理。STOMP可以用于任何可靠的双向流媒体网络协议，如TCP和WebSocket。尽管说 STOMP 是面向文本的协议，但消息负载仍然既可以为文本或者是二进制。</p><p>STOMP 是基于 HTTP 的一种基于框架的协议，下面是 STOMP 框架的结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">COMMAND<br>header1:value1<br>header2:value2<br><br>Body^@<br></code></pre></td></tr></table></figure><p>客户端可以使用 <code>SEND</code> 或 <code>SUBSCRIBE</code> 命令发送或订阅消息，还可以使用 <code>destination</code> 标头来描述消息的内容以及谁应该接收消息。这支持一种简单的发布-订阅机制，您可以使用该机制通过代理将消息发送到其他连接的客户端，或将消息发送到服务器以请求执行某些工作。</p><p>当你使用 Spring 的 STOMP 支撑模块时，Spring WebSocket 应用充当客户端的 STOMP 代理。消息被路由到 <code>@Controller</code> 消息处理方法或是简单的内存代理，该代理能够追踪订阅以及向订阅用户广播消息。</p><p>Spring 也支持配置专用的 STOMP 代理（如 RabbitMQ、ActiveMQ等等）来进行消息广播。在这种情况下，Spring 维护到代理的 TCP 连接，将消息转发给代理，并将消息从代理向下传递到连接的 WebSocket 客户端。</p><p>因此，Spring Web 应用可以依赖统一的基于 HTTP 安全，公共校验，以及熟悉的编程模型来处理消息。</p><p>订阅示例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">SUBSCRIBE<br>id:sub-1<br>destination:/topic/price.stock.*<br><br>^@<br></code></pre></td></tr></table></figure><p>客户端发送示例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">SEND<br>destination:/queue/trade<br>content-type:application/json<br>content-length:44<br><br>&#123;&quot;action&quot;:&quot;BUY&quot;,&quot;ticker&quot;:&quot;MMM&quot;,&quot;shares&quot;,44&#125;^@<br></code></pre></td></tr></table></figure><p>服务端广播消息给订阅者</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">MESSAGE<br>message-id:nxahklf6-1<br>subscription:sub-1<br>destination:/topic/price.stock.MMM<br><br>&#123;&quot;ticker&quot;:&quot;MMM&quot;,&quot;price&quot;:129.45&#125;^@<br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> TODO</li></ul><h3 id="4-4-2-好处"><a href="#4-4-2-好处" class="headerlink" title="4.4.2. 好处"></a>4.4.2. 好处</h3><ul><li><input disabled="" type="checkbox"> TODO</li></ul><h3 id="4-4-3-开启-STOMP"><a href="#4-4-3-开启-STOMP" class="headerlink" title="4.4.3. 开启 STOMP"></a>4.4.3. 开启 STOMP</h3><p>在 <code>spring-messaging</code> 和 <code>spring-websocket</code> 模块中提供了对WebSocket的支持。</p><p>配置示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;<br><span class="hljs-keyword">import</span> org.springframework.web.socket.config.annotation.StompEndpointRegistry;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSocketMessageBroker</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebSocketMessageBrokerConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerStompEndpoints</span><span class="hljs-params">(StompEndpointRegistry registry)</span> &#123;<br><span class="hljs-comment">// 1.声明 WebSocket/SockJS 客户端握手连接的 HTTP URL</span><br>        registry.addEndpoint(<span class="hljs-string">&quot;/portfolio&quot;</span>).withSockJS();  <br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureMessageBroker</span><span class="hljs-params">(MessageBrokerRegistry config)</span> &#123;<br><span class="hljs-comment">// 2.destination 头以 /app 为前缀的 STOMP 消息将路由到 @Controller 类中的 @MessageMapping 方法</span><br>        config.setApplicationDestinationPrefixes(<span class="hljs-string">&quot;/app&quot;</span>); <br><span class="hljs-comment">// 3.对于订阅和广播使用内置简单消息代理，路由destination 头以 /topic 和 /queue 为前缀的消息到代理</span><br>        config.enableSimpleBroker(<span class="hljs-string">&quot;/topic&quot;</span>, <span class="hljs-string">&quot;/queue&quot;</span>); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>💡 对于内置简单代理，<code>/topic</code> 和 <code>/queue</code> 并没有任何特殊含义。他们只是用来区分发布-订阅和点对点消息传递的一种约定。当使用外部代理时，请检查代理的 STOMP 页面，了解它支持哪种前缀。</p><p>关于 STOMP，可以选择的客户端库有</p><p><strong>项目中用到下面这个</strong></p><p><a href="https://github.com/jmesnil/stomp-websocket">jmesnil&#x2F;stomp-websocket</a></p><p><a href="https://github.com/JSteunou/webstomp-client">webstomp-client</a></p><h3 id="4-4-4-WebSocket-Server-服务端配置"><a href="#4-4-4-WebSocket-Server-服务端配置" class="headerlink" title="4.4.4. WebSocket Server 服务端配置"></a>4.4.4. WebSocket Server 服务端配置</h3><p>在上面的 <code>开启 STOMP</code> 部分已经提到，不再重复。</p><h3 id="4-4-5-Flow-of-Messages-消息流"><a href="#4-4-5-Flow-of-Messages-消息流" class="headerlink" title="4.4.5. Flow of Messages 消息流"></a>4.4.5. Flow of Messages 消息流</h3><p>一旦 STOMP 端点暴露出来，Spring应用就成为客户端连接的 STOMP 代理服务。</p><p><code>spring-messaging</code> 的一些抽象组件如下：</p><ul><li>Message：简单的消息，包括 header 和 payload。</li><li>MessageHandler：用于处理消息</li><li>MessageChannel：用于解构生产者和消费者发送消息这一过程</li><li>SubscribeChannel：MessageChannel with MessageHandler subscribers.</li><li>ExecutorSubscribableChannel：SubscribableChannel that uses an Executor for delivering messages.</li></ul><p>使用 Java 配置类（@EnableWebSocketMessageBroker）或是 XML 配置（<a href="websocket:message-broker">websocket:message-broker</a>）都使用上面的组件来组装消息工作流。</p><p>下图展示了启用内置消息代理时用到的组件：</p><p><img src="/note-of-websocket/Untitled%202.png" alt="note-of-websocket%2029723de254c64768a5242417d6575173/Untitled%202.png"></p><p>上图展示了 3 个消息频道：</p><ul><li><code>clientInboundChannel</code>: For passing messages received from WebSocket clients.</li><li><code>clientOutboundChannel</code>: For sending server messages to WebSocket clients.</li><li><code>brokerChannel</code>: For sending messages to the message broker from within server-side application code.</li></ul><p>下图展示了配置外部代理（如 RabbitMQ）来管理订阅和广播消息时使用的组件：</p><p><img src="/note-of-websocket/Untitled%203.png" alt="note-of-websocket%2029723de254c64768a5242417d6575173/Untitled%203.png"></p><p>以上最主要区别是使用了 <code>broker relay</code> 来通过 TCP 将消息向上传递到外部 STOMP 代理，以及将消息从代理向下传递到订阅的客户端。</p><p>WebSocket 连接发送的消息，会被解码成 STOMP 帧，转化成 Spring <code>Message</code>  表示，并被发送到 <code>clientInboundChannel</code> 做进一步处理。比如，以 <code>/app</code> 开头的消息会被路由到 controller 注解类中的 <code>@MessageMapping</code> 方法，以 <code>/topic</code> 和 <code>/queue</code> 开头的消息会被直接路由到消息代理。</p><p>An annotated @Controller that handles a STOMP message from a client may send a message to the message broker through the brokerChannel, and the broker broadcasts the message to matching subscribers through the clientOutboundChannel. The same controller can also do the same in response to HTTP requests, so a client can perform an HTTP POST, and then a @PostMapping method can send a message to the message broker to broadcast to subscribed clients.</p>]]></content>
    
    
    <categories>
      
      <category>分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>websocket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Security 笔记</title>
    <link href="/note-of-spring-security.html"/>
    <url>/note-of-spring-security.html</url>
    
    <content type="html"><![CDATA[<h1 id="docs-spring-io-x2F-spring-security"><a href="#docs-spring-io-x2F-spring-security" class="headerlink" title="docs.spring.io&#x2F;spring-security"></a>docs.spring.io&#x2F;spring-security</h1><p><a href="https://docs.spring.io/spring-security/site/docs/5.3.5.RELEASE/reference/html5/#servlet-authentication-mechanisms">Spring Security Reference</a></p><h1 id="9-Servlet-Security：The-Big-Picture"><a href="#9-Servlet-Security：The-Big-Picture" class="headerlink" title="9. Servlet Security：The Big Picture"></a>9. Servlet Security：The Big Picture</h1><h2 id="9-1-A-Review-of-Filter-s"><a href="#9-1-A-Review-of-Filter-s" class="headerlink" title="9.1. A Review of Filter s"></a>9.1. A Review of <code>Filter</code> s</h2><p><img src="/note-of-spring-security/Untitled.png" alt="/../image/note-of-spring-security/Untitled.png"></p><h2 id="9-2-DelegatingFilterProxy"><a href="#9-2-DelegatingFilterProxy" class="headerlink" title="9.2. DelegatingFilterProxy"></a>9.2. DelegatingFilterProxy</h2><p>Spring 提供了一个名为 <code>DelegatingFilterProxy</code> 的 <code>Filter</code> 实现，它允许在 Servlet 容器的生命周期和 Spring 的 <code>ApplicationContext</code> 之间建立桥接。</p><p><img src="/note-of-spring-security/Untitled%201.png" alt="/../image/note-of-spring-security/Untitled%201.png"></p><p><code>DelegatingFilterProxy</code> 从 <code>ApplicationContext</code> 查找 Bean Filter0，然后调用Bean Filter0。</p><p><strong>DelegatingFilterProxy 伪代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> &#123;<br>    <span class="hljs-comment">// Lazily get Filter that was registered as a Spring Bean</span><br>    <span class="hljs-comment">// For the example in DelegatingFilterProxy delegate is an instance of Bean Filter0</span><br>    <span class="hljs-type">Filter</span> <span class="hljs-variable">delegate</span> <span class="hljs-operator">=</span> getFilterBean(someBeanName);<br>    <span class="hljs-comment">// delegate work to the Spring Bean</span><br>    delegate.doFilter(request, response);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>DelegatingFilterProxy</code> 的另外一个好处是可以延迟查找 <code>Filter</code> Bean 实例。这很重要，因为容器需要在启动之前注册 <code>Filter</code> 实例。但是，Spring通常使用 <code>ContextLoaderListener</code> 来加载Spring Beans，这在需要注册的 <code>Filter</code> 实例注册之前是不会完成的。</p><h2 id="9-3-FilterChainProxy"><a href="#9-3-FilterChainProxy" class="headerlink" title="9.3. FilterChainProxy"></a>9.3. FilterChainProxy</h2><p>Spring Security 的 Servlet 支持包含在 <code>FilterChainProxy</code> 中。<code>FilterChainProxy</code> 是 Spring Security 提供的一个特殊的 <code>Filter</code> ，允许通过  <code>SecurityFilterChain</code> 代理给多个 Filter 实例工作。它通常被封装在 DelegatingFilterProxy 中。</p><p><img src="/note-of-spring-security/Untitled%202.png" alt="/../image/note-of-spring-security/Untitled%202.png"></p><h2 id="9-4-SecurityFilterChain"><a href="#9-4-SecurityFilterChain" class="headerlink" title="9.4. SecurityFilterChain"></a>9.4. SecurityFilterChain</h2><p><code>SecurityFilterChain</code> 被 FilterChainProxy 用来确定本次请求应该调用哪些 Spring Security的 <code>Filter</code> s。</p><p><img src="/note-of-spring-security/Untitled%203.png" alt="/../image/note-of-spring-security/Untitled%203.png"></p><p><img src="/note-of-spring-security/Untitled%204.png" alt="/../image/note-of-spring-security/Untitled%204.png"></p><h2 id="9-5-Security-Filters-过滤器"><a href="#9-5-Security-Filters-过滤器" class="headerlink" title="9.5. Security Filters 过滤器"></a>9.5. Security Filters 过滤器</h2><p>有时候知道 Security Filters 顺序是非常有用的。</p><ul><li>Spring Security Filter 的排序<ul><li><p>ChannelProcessingFilter</p></li><li><p>ConcurrentSessionFilter</p></li><li><p>WebAsyncManagerIntegrationFilter</p>  <aside>  💡 为后续的异步调用准备 WebAsyncManager    </aside>  </li><li><p>SecurityContextPersistenceFilter</p>  <aside>  💡 请求来临时，创建一个 SecurityContextHolder，本质上是 ThreadLocal；  请求处理完成时，清除 SecurityContextHolder。  解决在请求当前线程中的用户信息获取。    </aside>  </li><li><p>HeaderWriterFilter</p>  <aside>  💡 添加某些 header 启用浏览器保护的场景很有用。  比如X-Frame-Options, X-XSS-Protection和X-Content-Type-Options。    </aside>  </li><li><p>CorsFilter</p>  <aside>  💡 跨域处理，有默认实现。    </aside>  </li><li><p>CsrfFilter</p>  <aside>  💡 csrf token 相关    </aside>  </li><li><p>LogoutFilter 登出过滤器</p><p>  <img src="/note-of-spring-security/Untitled%205.png" alt="/../image/note-of-spring-security/Untitled%205.png"></p><p>  默认情况下匹配 <code>/logout</code> ，2 个 LogoutHandler</p><ol><li>SecurityContextLogoutHandler<ul><li>invalidateHttpSession &#x2F;&#x2F; 清除 Session</li><li>clearAuthentication &#x2F;&#x2F; 清除认证</li></ul></li><li>LogoutSuccessEventPublishingLogoutHandler 事件通知</li></ol></li><li><p>OAuth2AuthorizationRequestRedirectFilter</p></li><li><p>Saml2WebSsoAuthenticationRequestFilter</p></li><li><p>X509AuthenticationFilter</p></li><li><p>AbstractPreAuthenticatedProcessingFilter</p></li><li><p>CasAuthenticationFilter</p></li><li><p>OAuth2LoginAuthenticationFilter</p></li><li><p>Saml2WebSsoAuthenticationFilter</p></li><li><p><code>[UsernamePasswordAuthenticationFilter](https://docs.spring.io/spring-security/site/docs/5.3.5.RELEASE/reference/html5/#servlet-authentication-usernamepasswordauthenticationfilter)</code></p>  <aside>  💡 判断当前请求是否需要认证    </aside>  </li><li><p>ConcurrentSessionFilter</p></li><li><p>OpenIDAuthenticationFilter</p></li><li><p>DefaultLoginPageGeneratingFilter</p></li><li><p>DefaultLogoutPageGeneratingFilter</p></li><li><p><code>[DigestAuthenticationFilter](https://docs.spring.io/spring-security/site/docs/5.3.5.RELEASE/reference/html5/#servlet-authentication-digest)</code></p></li><li><p>BearerTokenAuthenticationFilter</p></li><li><p><code>[BasicAuthenticationFilter](https://docs.spring.io/spring-security/site/docs/5.3.5.RELEASE/reference/html5/#servlet-authentication-basic)</code></p></li><li><p>RequestCacheAwareFilter</p>  <aside>  💡 通常用于将原来的客户请求缓存下来，然后登录成功后将缓存的请求从缓存中提取出来。    </aside>  </li><li><p>SecurityContextHolderAwareRequestFilter</p>  <aside>  💡 对请求HttpServletRequest采用Wrapper/Decorator模式包装成一个可以访问SecurityContextHolder中安全上下文的SecurityContextHolderAwareRequestWrapper    </aside>  </li><li><p>JaasApiIntegrationFilter</p></li><li><p>RememberMeAuthenticationFilter</p></li><li><p>AnonymousAuthenticationFilter</p></li><li><p>OAuth2AuthorizationCodeGrantFilter</p></li><li><p>SessionManagementFilter</p>  <aside>  💡 检测从请求处理开始到目前是否有用户登录认证，如果有做相应的 session 管理，比如针对为新登录用户创建新的 session（session fixation防护）和设置新的 csrf token 等。    </aside>  </li><li><p><code>[ExceptionTranslationFilter](https://docs.spring.io/spring-security/site/docs/5.3.5.RELEASE/reference/html5/#servlet-exceptiontranslationfilter)</code></p>  <aside>  💡 处理 `AccessDeniedException` 和 `AuthenticationException` 异常，将它们转换成相应的 HTTP 响应。    </aside>  </li><li><p><code>[FilterSecurityInterceptor](https://docs.spring.io/spring-security/site/docs/5.3.5.RELEASE/reference/html5/#servlet-authorization-filtersecurityinterceptor)</code></p></li><li><p>SwitchUserFilter</p></li></ul></li></ul><h2 id="9-6-Handling-Security-Exceptions"><a href="#9-6-Handling-Security-Exceptions" class="headerlink" title="9.6. Handling Security Exceptions"></a>9.6. Handling Security Exceptions</h2><p><code>ExceptionTranslationFilter</code> 将会把 <code>AccessDeniedException</code> 和 <code>AuthenticationException</code> 转换成 HTTP 响应。</p><p><code>ExceptionTranslationFilter</code> 作为一个 Security Filter 插入到 FilterChainProxy 中。</p><p><img src="/note-of-spring-security/Untitled%206.png" alt="/../image/note-of-spring-security/Untitled%206.png"></p><p>元素过多</p><ul><li>DelegatingFilterProxy</li><li>FilterChainProxy（Bean Filter）</li><li>SecurityFilterChain</li></ul><h1 id="10-Authentication-身份验证"><a href="#10-Authentication-身份验证" class="headerlink" title="10. Authentication 身份验证"></a>10. Authentication 身份验证</h1><p><strong>Architecture Components</strong>（体系结构组件）</p><ul><li><code>SecurityContextHolder</code> - <code>Spring Security</code>存储身份验证的详细信息的地方</li><li><code>SecurityContext</code> - 来源于 <code>SecurityContextHolder</code> ，包含当前通过验证用户的身份验证信息</li><li><code>Authentication</code> - 可作为 <code>AuthenticationManager</code> 的输入，提供用户用于身份验证或是 <code>SecurityContext</code> 当前用户的凭证</li><li><code>GrantedAuthority</code> - 在 <code>Authentication</code> 中授予主体（principal）的权限（例如角色、域 scope 等）</li><li><code>AuthenticationManager</code> - 定义了 Spring Security 执行认证的 API</li><li><code>ProviderManager</code> - <code>AuthenticationManager</code> 最常用的实现</li><li><code>AuthenticationProvider</code> - <code>ProviderManeager</code> 用于执行特定类型的身份验证</li><li><code>Request Credentials with AuthenticationEntryPoint</code> - 客户端用于请求凭证（例如重定向到登录页，发送 <code>WWW-Authenticate</code> 响应等）</li><li><code>AbstractAuthenticationProcessingFilter</code> - 用于身份验证的基础 <code>Filter</code> 。由此能很好地了解上层身份验证流程以及各个部件是如何一起工作的。</li></ul><p><strong>Authentication Mechanisms</strong>（身份验证机制&#x2F;认证机制）</p><ul><li><a href="https://docs.spring.io/spring-security/site/docs/5.3.5.RELEASE/reference/html5/#servlet-authentication-unpwd">Username and Password</a> - how to authenticate with a username&#x2F;password</li><li><a href="https://docs.spring.io/spring-security/site/docs/5.3.5.RELEASE/reference/html5/#oauth2login">OAuth 2.0 Login</a> - OAuth 2.0 Log In with OpenID Connect and non-standard OAuth 2.0 Login (i.e. GitHub)</li><li><a href="https://docs.spring.io/spring-security/site/docs/5.3.5.RELEASE/reference/html5/#servlet-saml2">SAML 2.0 Login</a> - SAML 2.0 Log In</li><li><a href="https://docs.spring.io/spring-security/site/docs/5.3.5.RELEASE/reference/html5/#servlet-cas">Central Authentication Server (CAS)</a> - Central Authentication Server (CAS) Support</li><li><a href="https://docs.spring.io/spring-security/site/docs/5.3.5.RELEASE/reference/html5/#servlet-rememberme">Remember Me</a> - How to remember a user past session expiration</li><li><a href="https://docs.spring.io/spring-security/site/docs/5.3.5.RELEASE/reference/html5/#servlet-jaas">JAAS Authentication</a> - Authenticate with JAAS</li><li><a href="https://docs.spring.io/spring-security/site/docs/5.3.5.RELEASE/reference/html5/#servlet-openid">OpenID</a> - OpenID Authentication (not to be confused with OpenID Connect)</li><li><a href="https://docs.spring.io/spring-security/site/docs/5.3.5.RELEASE/reference/html5/#servlet-preauth">Pre-Authentication Scenarios</a> - Authenticate with an external mechanism such as <a href="https://www.siteminder.com/">SiteMinder</a> or Java EE security but still use Spring Security for authorization and protection against common exploits.</li><li><a href="https://docs.spring.io/spring-security/site/docs/5.3.5.RELEASE/reference/html5/#servlet-x509">X509 Authentication</a> - X509 Authentication</li></ul><h2 id="10-1-SecurityContextHolder"><a href="#10-1-SecurityContextHolder" class="headerlink" title="10.1. SecurityContextHolder"></a>10.1. SecurityContextHolder</h2><p>作为 <code>Spring Security</code> 的认证模型核心，它包含了 <code>SecurityContext</code> 。</p><p><img src="/note-of-spring-security/Untitled%207.png" alt="/../image/note-of-spring-security/Untitled%207.png"></p><p><code>SecurityContextHolder</code>是 <code>Spring Security</code> 用来存储了已认证用户的详细信息的类。</p><p><strong>表示用户已通过身份验证最简单的方法就是</strong> <code>Set</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SecurityContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SecurityContextHolder.createEmptyContext();<span class="hljs-comment">// 1 </span><br><span class="hljs-type">Authentication</span> <span class="hljs-variable">authentication</span> <span class="hljs-operator">=</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestingAuthenticationToken</span>(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;ROLE_USER&quot;</span>); <span class="hljs-comment">// 2</span><br>context.setAuthentication(authentication);<br><br>SecurityContextHolder.setContext(context); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><aside>💡 1、首先创建一个新的 `SecurityContext` 实例，而不是使用 `SecurityContextHolder.getContext().setAuthentication(authentication)` ，从而避免多线程的竞争问题。2、Spring Security 不关心 `Authentication`的实现。更常见的方案是使用 `UsernamePasswordAuthenticationToken(userDetails, password, authorities)`3、Spring Security 将使用这份信息去 authorization（授权）</aside><p><strong>访问当前已认证的用户信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SecurityContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SecurityContextHolder.getContext();<br><span class="hljs-type">Authentication</span> <span class="hljs-variable">authentication</span> <span class="hljs-operator">=</span> context.getAuthentication();<br><span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> authentication.getName();<br><span class="hljs-type">Object</span> <span class="hljs-variable">principal</span> <span class="hljs-operator">=</span> authentication.getPrincipal();<br>Collection&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GrantedAuthority</span>&gt; authorities = authentication.getAuthorities();<br></code></pre></td></tr></table></figure><p>默认情况下，<code>SecurityContextHolder</code> 使用 <code>ThreadLocal</code> 存储信息，意味着没有显式传参给方法，也能在同一线程方法中使用 <code>SecurityContext</code>。</p><p>如果在当前主体的请求被处理后清除线程，那么以这种方式使用 <code>ThreadLocal</code> 是非常安全的。<code>FilterChainProxy</code> 确保 <code>SecurityContext</code> 总是被清除。</p><p>有些应用程序并不完全适合使用 <code>ThreadLocal</code>，这是因为它们使用线程的特定方式。可以根据具体的场景使用 <code>SecurityContextHolder</code> 不同的策略。</p><h2 id="10-2-SecurityContext"><a href="#10-2-SecurityContext" class="headerlink" title="10.2 SecurityContext"></a>10.2 SecurityContext</h2><p> 从 <code>SecurityContextHolder</code> 可以获得 <code>SecurityContext</code>，包含了 <code>Authentication</code> 对象。</p><h2 id="10-3-Authentication"><a href="#10-3-Authentication" class="headerlink" title="10.3. Authentication"></a>10.3. Authentication</h2><p><code>Authentication</code> 主要用于两个意图：</p><ul><li>提供认证： <code>AuthenticationManager</code> 的输入，用于提供用户身份验证的凭据。这种情况，<code>isAuthenticated()</code> 返回 <code>false</code>。</li><li>认证成功：表示当前经过身份验证的用户，<code>isAuthenticated()</code> 返回 <code>true</code>。当前的<code>Authentication</code> 可以从 <code>SecurityContext</code> 获得。</li></ul><p><code>Authentication</code> 包含：</p><ul><li><code>principal</code> - 标识用户。通过 username&#x2F;password 认证的通常是 <code>UserDetails</code> 的实例。</li><li><code>credentials</code> - 密码。通常确保在用户登录后清除，避免泄露。</li><li><code>authorities</code> - 用户被授予的上层权限（the <code>[GrantedAuthority</code>s](<a href="https://docs.spring.io/spring-security/site/docs/5.3.5.RELEASE/reference/html5/#servlet-authentication-granted-authority">https://docs.spring.io/spring-security/site/docs/5.3.5.RELEASE/reference/html5/#servlet-authentication-granted-authority</a>) are high level permissions the user is granted.） A few examples are roles or scopes.</li></ul><h2 id="10-4-GrantedAuthority（权限）"><a href="#10-4-GrantedAuthority（权限）" class="headerlink" title="10.4. GrantedAuthority（权限）"></a>10.4. GrantedAuthority（权限）</h2><p>角色、作用域。</p><p><code>GrantedAuthority</code>s 可以通过 <code>Authentication.getAuthorities()</code> 方法来获得。方法返回 <code>GrantedAuthority</code> 对象的集合。<code>GrantedAuthority</code> 就是授予主体的权限。这些权限通常就是 “roles”，例如 <code>ROLE_ADMINISTRATOR</code> 或 <code>ROLE_HR_SUPERVISOR</code> 。这些角色后续配置用于 web 授权，方法授权和域对象授权。Other parts of Spring Security are capable of interpreting these authorities, and expect them to be present. When using username&#x2F;password based authentication GrantedAuthoritys are usually loaded by the UserDetailsService.</p><p>Usually the GrantedAuthority objects are application-wide permissions. They are not specific to a given domain object. Thus, you wouldn’t likely have a GrantedAuthority to represent a permission to Employee object number 54, because if there are thousands of such authorities you would quickly run out of memory (or, at the very least, cause the application to take a long time to authenticate a user). Of course, Spring Security is expressly designed to handle this common requirement, but you’d instead use the project’s domain object security capabilities for this purpose.</p><h2 id="10-5-AuthenticationManager"><a href="#10-5-AuthenticationManager" class="headerlink" title="10.5. AuthenticationManager"></a>10.5. AuthenticationManager</h2><p><code>AuthenticationManager</code> 是定义 Spring Security 过滤器如何执行身份验证的 API。由调用 <code>AuthenticationManager</code> 的控制器（即 Spring Security Filters）在 <code>SecurityContextHolder</code> 上设置返回的身份验证。如果没有集成 Spring Security 的过滤器，可以直接设置 <code>SecurityContextHolder</code>  而不需要使用 <code>AuthenticationManager</code> 。</p><h2 id="10-6-ProviderManager"><a href="#10-6-ProviderManager" class="headerlink" title="10.6. ProviderManager"></a>10.6. ProviderManager</h2><p><code>ProviderManager</code> 是 <code>AuthenticationManager</code> 最常见的实现。<code>ProviderManager</code> 代理了一个 AuthenticationProviders 的列表（List）. 每一个 <code>AuthenticationProvider</code> 都有机会去指出身份验证为成功，失败或者不能做出判断并允许下游的 AuthenticationProvider 去决策。如果配置的 AuthenticationProviders 都不能够验证身份，那么身份验证会伴随 ProviderNotFoundException 异常失败，代表找不到该 Authentication 身份验证的相关支持。</p><p><img src="/note-of-spring-security/Untitled%208.png" alt="/../image/note-of-spring-security/Untitled%208.png"></p><p>事实上每个 <code>AuthenticationProvider</code> 都可以执行特定方式的认证。例如，其中一个 <code>AuthenticationProvider</code> 能够验证 账号&#x2F;密码，另一个能够通过 SAML 的方式进行验证。这就支持只暴露一个 <code>AuthenticationManager</code> bean 就能够支持多种方式的身份验证。</p><p><code>ProviderManager</code> 也可以配置一个（可选的）父级 <code>AuthenticationManager</code> ，用于没有 <code>AuthenticationProvider</code> 能够执行身份验证时进行决策。这个父级通常是一个 <code>ProviderManager</code> 实现。</p><p><img src="/note-of-spring-security/Untitled%209.png" alt="/../image/note-of-spring-security/Untitled%209.png"></p><p>通常，多个 <code>ProviderManager</code> 可以共享同一个父级 <code>AuthenticationManager</code> 。这种实践方式常见于多个 <code>SecurityFilterChain</code> 有部分公共的身份认证（共享的父级 <code>AuthenticationManager</code>），也有部分不同的身份验证机制（不同的 <code>ProviderManager</code> 实例）。</p><p><img src="/note-of-spring-security/Untitled%2010.png" alt="/../image/note-of-spring-security/Untitled%2010.png"></p><p>默认情况下，<code>ProviderManager</code> 会尝试去清除由成功认证请求返回的 <code>Authentication</code> 对象种的敏感凭证信息。这可以防止诸如密码之类的信息在 <code>HttpSession</code> 中长时间保留。</p><p>在使用用户对象缓存时（例如，在无状态应用中提升性能），可能有潜在的问题。如果 <code>Authentication</code> 在缓存中包含了对象（例如 <code>UserDetails</code> 实例）的引用，而它的凭证被移除，这将会导致不再能够通过缓存的值进行身份验证。如果你正在使用缓存，必须考虑到这一点。一个常见的解决方案是先复制对象，要么在缓存中实现，要么在创建返回 <code>Authentication</code> 对象的 <code>AuthenticationProvider</code> 中实现。另外，可以考虑禁止 ProviderManger  的<code>eraseCredentialsAfterAuthentication</code> 字段。</p><h2 id="10-7-AuthenticationProvider"><a href="#10-7-AuthenticationProvider" class="headerlink" title="10.7. AuthenticationProvider"></a>10.7. AuthenticationProvider</h2><p>可以注入多种 <code>AuthenticationProvider</code> s 到 <code>ProviderManager</code> 中。每个 <code>AuthenticationProvider</code> 都执行特定方式的认证过程。例如 <code>DaoAuthenticationProvider</code> 支持基于用户名&#x2F;密码的认证，而 <code>JwtAuthenticationProvider</code> 支持 JWT token 验证。</p><h2 id="10-8-Request-Credentials-with-AuthenticationEntryPoint"><a href="#10-8-Request-Credentials-with-AuthenticationEntryPoint" class="headerlink" title="10.8. Request Credentials with AuthenticationEntryPoint"></a>10.8. Request Credentials with <code>AuthenticationEntryPoint</code></h2><p><code>AuthenticationEntryPoint</code> 是客户端用于请求凭证发送的 HTTP 相应。 </p><p>有些时候客户端会携带凭证（例如账号&#x2F;密码）去请求资源。在这些情况下，Spring Security不需要提供从客户端请求凭据的HTTP响应，因为它们已经包含在内了。</p><p>其它情况下，客户端会向他们没有权限访问的资源发出未经身份验证的请求。<code>AuthenticationEntryPoint</code> 的实现用于客户端请求凭证。其实现可能会执行重定向到登录页，返回 WWW-Authenticate 响应头，等等。</p><h2 id="10-9-AbstractAuthenticationProcessingFilter"><a href="#10-9-AbstractAuthenticationProcessingFilter" class="headerlink" title="10.9. AbstractAuthenticationProcessingFilter"></a>10.9. AbstractAuthenticationProcessingFilter</h2><p><code>AbstractAuthenticationProcessingFilter</code> 是用于认证用户凭证的基础 <code>Filter</code> 。在凭证被验证之前，Spring Security 通常会使用 <code>AuthenticationEntryPoint</code> 来请求凭证。</p><p>接下来，<code>AbstractAuthenticationProcessingFilter</code> 可以验证提交的任何身份验证请求。</p><p><img src="/note-of-spring-security/Untitled%2011.png" alt="/../image/note-of-spring-security/Untitled%2011.png"></p><ol><li>当用户提交他们的凭证，<code>AbstractAuthenticationProcessingFilter</code> 会从 <code>HttpServletRequest</code> 创建一个 <code>Authentication</code> 去做身份验证。<code>Authentication</code> 的类型取决于 <code>AbstractAuthenticationProcessingFilter</code> 的子类。例如，<code>UsernamePasswordAuthenticationFilter</code> 从 <code>HttpServletRequest</code> 提交的 username 和 password 创建一个 <code>UsernamePasswordAuthenticationToken</code> （<code>Authentication</code> 的一种实现）。</li><li>接着，<code>Authentication</code> 传递到 <code>AuthenticationManager</code> 做身份验证。</li><li>如果身份验证失败，则<ul><li>清空 <code>SecurityContextHolder</code></li><li>调用 <code>RememberMeServices.loginFail</code> 。如果没有配置 remember me，则无操作。</li><li>调用 <code>AuthenticationFailureHandler</code></li></ul></li><li>如果身份验证成功，则<ul><li><code>SessionAuthenticationStrategy</code> 收到新的登录通知</li><li><code>Authentication</code> 被 set 到 <code>SecurityContextHolder</code> 。后续<code>SecurityContextPersistenceFilter</code> 会将 <code>SecurityContext</code> 保存到 <code>HttpSession</code> 。</li><li>调用 <code>RememberMeServices.loginSuccess</code> 。如果没有配置 remember me，则无操作。</li><li><code>ApplicationEventPublisher</code> 发布 <code>InteractiveAuthenticationSuccessEvent</code> 。</li></ul></li></ol><h2 id="10-17-CAS-Authentication"><a href="#10-17-CAS-Authentication" class="headerlink" title="10.17. CAS Authentication"></a>10.17. CAS Authentication</h2><h1 id="11-Authorization"><a href="#11-Authorization" class="headerlink" title="11. Authorization"></a>11. Authorization</h1><h2 id="11-1-Authorization-Architecture"><a href="#11-1-Authorization-Architecture" class="headerlink" title="11.1 Authorization Architecture"></a>11.1 Authorization Architecture</h2><p>在本部分中，我们将探索在第1部分中介绍的不同的 <code>AbstractSecurityInterceptor</code> 实现。然后，我们将继续探索如何通过使用域访问控制列表来调优授权。</p><h3 id="11-1-1-Authorities"><a href="#11-1-1-Authorities" class="headerlink" title="11.1.1. Authorities"></a>11.1.1. Authorities</h3><p>身份验证，讨论所有身份验证实现如何存储授予权限对象的列表。</p><p>这些代表了被授予给用户权限。 <code>AuthenticationManager</code> 插入<code>GrantedAuthority</code> 对象到 <code>Authentication</code> 中，之后授权决策时由 <code>AccessDecisionManager</code>读取。</p><p><code>GrantedAuthority</code> 是只有一个方法的接口，表示已认证对象被授予的权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">getAuthority</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>一般由 AccessDecisionManager 获取权限的 String 形式，来做最终的访问控制决策。</p><p>如果 String 不能很好的表示，应该被认定为“复杂”权限，并且该接口返回 null。（例如存储应用于不同客户账号的操作列表和权限阈值的实现。将这个复杂的授权表示为字符串将非常困难）</p><p>返回 <code>null</code> 会让 <code>AccessDecisionManager</code> 特别支持 <code>GrantedAuthority</code> 实现来识别权限列表。</p><p>Spring Security 包括一个具体的 <code>GrantedAuthority</code> 实现，<code>SimpleGrantedAuthority</code>。它将任何用户指定的字符串转换为已授予的权限。安全体系结构中包含的所有 <code>AuthenticationProvider</code>都使用<code>SimpleGrantedAuthority</code> 来填充身份验证对象。</p><h3 id="11-1-2-Pre-Invocation-Handling（调用前处理）"><a href="#11-1-2-Pre-Invocation-Handling（调用前处理）" class="headerlink" title="11.1.2. Pre-Invocation Handling（调用前处理）"></a>11.1.2. Pre-Invocation Handling（调用前处理）</h3><p>Spring Security 提供了用于控制对安全对象（如方法调用或web请求）访问拦截器。</p><p><code>AccessDecisionManager</code> 对是否允许进行调用做出调用前决策。</p><ul><li><strong>The AccessDecisionManager</strong></li></ul><p><code>AccessDecisionManager</code> 由 <code>AbstractSecurityInterceptor</code> 调用，负责做出最终的访问控制决策。</p><p><code>AccessDecisionManager</code> 接口包含 3 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">decide</span><span class="hljs-params">(Authentication authentication, Object secureObject,</span><br><span class="hljs-params">    Collection&lt;ConfigAttribute&gt; attrs)</span> <span class="hljs-keyword">throws</span> AccessDeniedException;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">supports</span><span class="hljs-params">(ConfigAttribute attribute)</span>;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">supports</span><span class="hljs-params">(Class clazz)</span>;<br></code></pre></td></tr></table></figure><p><code>AccessDecisionManager</code> 的 <code>decision</code> 方法传递了它做出授权决策所需的所有相关信息。特别是，通过传递安全对象，可以检查实际安全对象调用中包含的参数。例如，我们假设安全对象是一个方法调用。</p><p>如果访问被拒绝，实现将抛出AccessDeniedException异常。</p><ul><li><p><strong>Voting-Based AccessDecisionManager Implementations（基于投票的实现）</strong></p><p>  <img src="/note-of-spring-security/Untitled%2012.png" alt="Voting Decision Manager"></p><p>  Voting Decision Manager</p></li></ul><h2 id="11-2-Authorize-HttpServletRequest-with-FilterSecurityInterceptor"><a href="#11-2-Authorize-HttpServletRequest-with-FilterSecurityInterceptor" class="headerlink" title="11.2. Authorize HttpServletRequest with FilterSecurityInterceptor"></a>11.2. Authorize HttpServletRequest with FilterSecurityInterceptor</h2><h2 id="11-3-Expression-Based-Access-Control（基于表达式的访问控制）"><a href="#11-3-Expression-Based-Access-Control（基于表达式的访问控制）" class="headerlink" title="11.3. Expression-Based Access Control（基于表达式的访问控制）"></a>11.3. Expression-Based Access Control（基于表达式的访问控制）</h2><h2 id="11-4-Secure-Object-Implementations"><a href="#11-4-Secure-Object-Implementations" class="headerlink" title="11.4. Secure Object Implementations"></a>11.4. Secure Object Implementations</h2><h2 id="11-5-Method-Security"><a href="#11-5-Method-Security" class="headerlink" title="11.5. Method Security"></a>11.5. Method Security</h2><h2 id="11-6-Domain-Object-Security（ACLs）"><a href="#11-6-Domain-Object-Security（ACLs）" class="headerlink" title="11.6. Domain Object Security（ACLs）"></a>11.6. Domain Object Security（ACLs）</h2>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
