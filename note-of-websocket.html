

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="">
  <meta name="keywords" content="">
  
    <meta name="description" content="WebSocket 学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="WebSocket笔记">
<meta property="og:url" content="https://quan7u.github.io/note-of-websocket">
<meta property="og:site_name" content="quan7u">
<meta property="og:description" content="WebSocket 学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://quan7u.github.io/note-of-websocket/Untitled.png">
<meta property="og:image" content="https://quan7u.github.io/note-of-websocket/Untitled%201.png">
<meta property="og:image" content="https://quan7u.github.io/note-of-websocket/Untitled%202.png">
<meta property="og:image" content="https://quan7u.github.io/note-of-websocket/Untitled%203.png">
<meta property="article:published_time" content="2020-11-13T16:00:00.000Z">
<meta property="article:modified_time" content="2022-08-11T01:52:41.748Z">
<meta property="article:tag" content="websocket">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://quan7u.github.io/note-of-websocket/Untitled.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>WebSocket笔记 - quan7u</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"quan7u.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 30vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>quan7u</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="WebSocket笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-11-14 00:00" pubdate>
          2020年11月14日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          89 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">WebSocket笔记</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="spring-websocket-总览"><a href="#spring-websocket-总览" class="headerlink" title="spring-websocket 总览"></a>spring-websocket 总览</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">└── web<br>   └── socket<br>      ├── adapter #适配 Spring WebSocket 对 Java 标准 WebSocket API 适配（还有 Jetty 标准实现）包括有编解码、相互扩展、处理器、Session<br>      ├── client #客户端  Spring 对 WebSocket 客户端以及 Java 标准 WebSocket endpoints 实现<br>      ├── config #对 WebSocket 请求处理的配置（xml 配置和基于注解的配置支持）<br>      ├── handler #针对 WebSocketHandler 的实现和装饰<br>      ├── messaging #WebSocket 集成 Spring messaging <br>      ├── server #WebSocket 交互的服务端抽象<br>      ├── sockjs #Top-level SockJS types.<br>      ├── AbstractWebSocketMessage.java #抽象消息<br>      ├── BinaryMessage.java  #二进制消息<br>      ├── CloseStatus.java #WebSocket 关闭状态码和原因<br>      ├── <span class="hljs-keyword">package</span>-info.java <br>      ├── PingMessage.java<br>      ├── PongMessage.java <br>      ├── SubProtocolCapable.java #WebSocket 标准中定义的 WebSocket 处理器子协议接口<br>      ├── TextMessage.java #文本消息<br>      ├── WebSocketExtension.java #扩展<br>      ├── WebSocketHandler.java #WebSocket 消息和生命周期事件处理器（ExceptionWebSocketHandlerDecorator 提供异常处理策略）<br>      ├── WebSocketHttpHeaders.java #增加了 WebSocket 规范的 http 头<br>      ├── WebSocketMessage.java #消息顶级接口<br>      └── WebSocketSession.java #WebSocket session 顶级接口<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38345296/article/details/104040612">WebSocket实战详解【Springboot+Vue+sockjs+webstomp】_Slience Wind-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011943534/article/details/97098687">springboot学习(二十一) springboot中websocket使用@MessageMapping接收各种类型数据_文若书生的专栏-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/elonpage/article/details/78446695?locationNum=5&fps=1">Spring+STOMP实现WebSocket广播订阅、权限认证、一对一通讯（附源码）_杰明Jamin的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web.html#websocket-stomp">Web on Servlet Stack</a></p>
<p><a target="_blank" rel="noopener" href="http://www.mydlq.club/article/86/">SpringBoot 实现 Websocket 通信详解</a></p>
<h1 id="身份认证及鉴权"><a href="#身份认证及鉴权" class="headerlink" title="身份认证及鉴权"></a>身份认证及鉴权</h1><ul>
<li>握手鉴权（通过 Session）</li>
<li>首次发送消息拦截（通过 WebSocket &#x2F; Stomp 连接方法携带 header）</li>
</ul>
<p><img src="/note-of-websocket/Untitled.png" srcset="/img/loading.gif" lazyload alt="note-of-websocket%2029723de254c64768a5242417d6575173/Untitled.png"></p>
<ol>
<li>登录（Session）</li>
<li>WebSocket 连接（关联 Session）</li>
<li>后续业务<ul>
<li>判断用户是否在线</li>
<li>推送</li>
</ul>
</li>
</ol>
<p>潜在问题：</p>
<ol>
<li>连接中断（快速的恢复连接）</li>
<li>发送消息失败（考虑下次重连发送 Redis）</li>
</ol>
<h1 id="https-与-wss"><a href="#https-与-wss" class="headerlink" title="https 与 wss"></a>https 与 wss</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mafly/p/websocket.html">WebSocket 结合 Nginx 实现域名及 WSS 协议访问</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.mattermost.com/install/troubleshooting.html#failed-to-upgrade-websocket-connection">Important Notes - Mattermost 5.28 documentation</a></p>
<h1 id="4-Spring-Doc（WebSocket-部分）"><a href="#4-Spring-Doc（WebSocket-部分）" class="headerlink" title="4. Spring Doc（WebSocket 部分）"></a>4. Spring Doc（WebSocket 部分）</h1><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket">Web on Servlet Stack</a></p>
<h2 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1. 介绍"></a>4.1. 介绍</h2><p><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6455">RFC 6455 - The WebSocket Protocol</a></p>
<p>The WebSocket protocol, RFC 6455, provides a standardized way to establish a full-duplex, two-way communication channel between client and server over a single TCP connection.</p>
<h3 id="4-1-1-Http-VS-WebSocket"><a href="#4-1-1-Http-VS-WebSocket" class="headerlink" title="4.1.1. Http VS WebSocket"></a>4.1.1. Http VS WebSocket</h3><p>尽管 WebSocket 被设计成兼容 HTTP 并始于 HTTP 请求，但这两种协议会导致非常不同的体系结构和编程模型，理解这一点很重要。</p>
<p>在 HTTP 和 REST 中，应用的建模基于众多的 URL。客户端以「请求-响应」的方式访问那些 URL，从而与应用服务进行交互。服务端根据 HTTP URL、method 和 headers 来将请求路由到正确的处理器。</p>
<p>相比之下，通常只有一个用于初始化连接的 URL 在 WebSocket 中。随后，所有的应用消息都在同一 TCP 连接之上传输。这就指向了一个完全不一样的异步的、事件驱动的消息传递体系结构。</p>
<p>与 HTTP 不同的是，WebSocket 是一种低级传输协议。它不规定消息内容的任何语义。这意味着，除非客户端和服务端在消息语义上达成一致，否则无法路由或者处理消息。</p>
<p>通过 HTTP 握手请求的 <code>Sec-WebSocket-Protocol</code> 请求头，WebSocket 客户端和服务端可以协商使用更高级的消息传递协议（比如说 STOMP）。这种情况下，需要限定他们自己的规范。</p>
<h3 id="4-1-2-什么时候应该使用-WebSocket"><a href="#4-1-2-什么时候应该使用-WebSocket" class="headerlink" title="4.1.2. 什么时候应该使用 WebSocket"></a>4.1.2. 什么时候应该使用 WebSocket</h3><p>WebSocket 旨在使得网页是动态和交互的。然而，一般情况下，Ajax &amp; HTTP 和长轮询就能够提供简单有效的解决方案。</p>
<p>举个例子，类似新闻、邮件和社交流需要动态更新，但是几分钟更新一次是可以被接受的。而在协同、游戏和金融应用中，更新的频率需要接近实时。</p>
<p>It is the combination of low latency, high frequency, and high volume that make the best case for the use of WebSocket.</p>
<p>低时延，高频率和高容量的组合即是使用 WebSocket 的最佳场景。</p>
<p>还需要注意的是，在你控制之外的限制性代理可能会阻止 WebSocket 交互，要么因为他们没有设置 <code>Upgrade</code>请求头，要么因为他们关闭长时间空闲的连接。This means that the use of WebSocket for internal applications within the firewall is a more straightforward decision than it is for public facing applications.（不太好翻译，大概就是说防火墙内的内部应用使用 WebSocket 的成本更低）</p>
<h2 id="4-2-WebSocket-API"><a href="#4-2-WebSocket-API" class="headerlink" title="4.2. WebSocket API"></a>4.2. WebSocket API</h2><p>The Spring Framework provides a WebSocket API that you can use to write client- and server-side applications that handle WebSocket messages.</p>
<h3 id="4-2-1-WebSocketHandler"><a href="#4-2-1-WebSocketHandler" class="headerlink" title="4.2.1. WebSocketHandler"></a>4.2.1. WebSocketHandler</h3><p><img src="/note-of-websocket/Untitled%201.png" srcset="/img/loading.gif" lazyload alt="note-of-websocket%2029723de254c64768a5242417d6575173/Untitled%201.png"></p>
<p>Spring WebSocket 模块不基于 Spring MVC。通过 <code>WebSocketHttpRequestHandler</code> ，将 <code>WebSocketHandler</code> 集成到其它 HTTP 服务环境相对简单。</p>
<p> 当直接或者间接使用 <code>WebSocketHandler</code> API 时（例如通过 STOMP 消息传递），应用必须同步发送消息，因为底层标准 WebSocket Session（JSR-356）不允许并发发送。一种可选方案是用 <code>ConcurrentWebSocketSessionDecorator</code>来包装 <code>WebSocketSession</code> 。</p>
<h3 id="4-2-2-WebSocket-握手"><a href="#4-2-2-WebSocket-握手" class="headerlink" title="4.2.2. WebSocket 握手"></a>4.2.2. WebSocket 握手</h3><aside>
💡 Spring 提供了 `WebSocketHandlerDecorator`  基类来用附加行为装饰 `WebSocketHandler` 。
默认 Java 配置或 XML 配置下，日志和异常处理提供默认实现。
`ExceptionWebSocketHandlerDecorator` 捕获来自任何 `WebSocketHandler` 方法的所有未捕获异常，并以状态`1011` 关闭WebSocket会话，这表示一个服务器错误。

</aside>

<h3 id="4-2-3-Deployment"><a href="#4-2-3-Deployment" class="headerlink" title="4.2.3. Deployment"></a>4.2.3. Deployment</h3><ul>
<li><input disabled="" type="checkbox"> TODO</li>
</ul>
<h3 id="4-2-4-Server-Configuration-服务端配置"><a href="#4-2-4-Server-Configuration-服务端配置" class="headerlink" title="4.2.4. Server Configuration 服务端配置"></a>4.2.4. Server Configuration 服务端配置</h3><p>每个底层 WebSocket 引擎都开放了供控制运行时特性的配置属性，比如消息缓冲区大小、空闲超时时间等等。</p>
<p>对于 Tomcat 等容器（除 Jetty），你可以注入 <code>ServletServerContainerFactoryBean</code> 到你的配置类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSocket</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebSocketConfigurer</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ServletServerContainerFactoryBean <span class="hljs-title function_">createWebSocketContainer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ServletServerContainerFactoryBean</span> <span class="hljs-variable">container</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletServerContainerFactoryBean</span>();<br>        container.setMaxTextMessageBufferSize(<span class="hljs-number">8192</span>);<br>        container.setMaxBinaryMessageBufferSize(<span class="hljs-number">8192</span>);<br>        <span class="hljs-keyword">return</span> container;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于 Jetty，则需要提供一个预配置的握手处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> DefaultHandshakeHandler <span class="hljs-title function_">handshakeHandler</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">WebSocketPolicy</span> <span class="hljs-variable">policy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketPolicy</span>(WebSocketBehavior.SERVER);<br>    policy.setInputBufferSize(<span class="hljs-number">8192</span>);<br>    policy.setIdleTimeout(<span class="hljs-number">600000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultHandshakeHandler</span>(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">JettyRequestUpgradeStrategy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketServerFactory</span>(policy)));<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-2-5-Allowed-Origins"><a href="#4-2-5-Allowed-Origins" class="headerlink" title="4.2.5. Allowed Origins"></a>4.2.5. Allowed Origins</h3><p>默认只支持同源请求，也可以自定义配置。</p>
<p>（Nothing prevents other types of clients from modifying the Origin header value）</p>
<p>有 3 种可能的情况：</p>
<ol>
<li><p>只允许同源请求（默认配置下）</p>
<p> In this mode, when SockJS is enabled, the Iframe HTTP response header X-Frame-Options is set to SAMEORIGIN, and JSONP transport is disabled, since it does not allow checking the origin of a request. As a consequence, IE6 and IE7 are not supported when this mode is enabled.</p>
</li>
<li><p>指定的 origins 列表</p>
<p> Each allowed origin must start with http:&#x2F;&#x2F; or https:&#x2F;&#x2F;. In this mode, when SockJS is enabled, IFrame transport is disabled. As a consequence, IE6 through IE9 are not supported when this mode is enabled.</p>
</li>
<li><p>允许所有 origins（这种情况下，所有传输都有效，应该是推荐这种配置）</p>
<p> To enable this mode, you should provide * as the allowed origin value. In this mode, all transports are available.</p>
</li>
</ol>
<h2 id="4-3-SockJS-Fallback（回退）"><a href="#4-3-SockJS-Fallback（回退）" class="headerlink" title="4.3. SockJS Fallback（回退）"></a>4.3. SockJS Fallback（回退）</h2><p>公网上，限制性代理可能会阻止 WebSocket 交互。（可能没有配置 <code>Upgrade</code> 头升级协议，可能长时间空闲被关闭连接）</p>
<p>解决上述问题的方案就是 WebSocket 模拟：先尝试使用 WebSocket，（不成功）再尝试使用基于 HTTP 的技术来模拟 WebSocket 的交互，同时暴露相对应的应用级别的 API。</p>
<h3 id="4-3-1-总览"><a href="#4-3-1-总览" class="headerlink" title="4.3.1. 总览"></a>4.3.1. 总览</h3><p>SockJS 的目的是让应用再运行时使用 WebSocket API，必要时退回非 WebSocket的模式，而不需要修改应用代码。</p>
<p>本章 SockJS 由以下组成：</p>
<ul>
<li>SockJS 协议 <a target="_blank" rel="noopener" href="https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html">https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html</a></li>
<li>SockJS JavaScript 客户端 —— 浏览器端的客户端库</li>
<li>SockJS 服务端实现，例如 <code>spring-websocket</code></li>
<li>SockJS Java 客户端（包含在 <code>spring-websocket</code> )</li>
</ul>
<p>SockJS 为浏览器设计。传输可以分为 3 类：</p>
<ol>
<li>WebSocket</li>
<li>HTTP Streaming（我理解为 ajax？</li>
<li>HTTP Long Polling（长轮询</li>
</ol>
<p>具体参考下文</p>
<p><a target="_blank" rel="noopener" href="https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/">Spring MVC 3.2 Preview: Techniques for Real-time Updates</a></p>
<p>SockJS 客户端发送 GET 请求 <code>/info</code> 从服务端获取基本信息，从而决定使用哪一种传输方式。</p>
<p>WebSocket → HTTP streaming → HTTP（long）polling</p>
<p>所有传输请求都具有以下 URL 结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">https://host:port/myApp/myEndpoint/&#123;server-id&#125;/&#123;session-id&#125;/&#123;transport&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>&#123;server-id&#125;</code> 对于集群中的路由请求十分有用。</li>
<li><code>&#123;session-id&#125;</code> 将属于 SockJS 会话的 HTTP 请求关联起来。</li>
<li><code>&#123;transport&#125;</code> 表示传输方式 (例如, <code>websocket</code>, <code>xhr-streaming</code> 等).</li>
</ul>
<p>WebSocket 传输只需要一次 HTTP 请求来做 WebSocket 握手，之后所有消息传输交换都在该连接（socket）上。</p>
<p>SockJS adds minimal message framing.（最小消息帧）</p>
<p><code>o</code> open frame</p>
<p><code>h</code> heartbeat frame</p>
<p><code>c</code> close frame</p>
<h3 id="4-3-2-开启-SockJS"><a href="#4-3-2-开启-SockJS" class="headerlink" title="4.3.2. 开启 SockJS"></a>4.3.2. 开启 SockJS</h3><p>通过配置类开启 <code>withSockJS()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSocket</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebSocketConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerWebSocketHandlers</span><span class="hljs-params">(WebSocketHandlerRegistry registry)</span> &#123;<br>        registry.addHandler(myHandler(), <span class="hljs-string">&quot;/myHandler&quot;</span>).withSockJS();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>sockjs-client</code> 取决于浏览器</p>
<p><a target="_blank" rel="noopener" href="https://github.com/sockjs/sockjs-client/">sockjs&#x2F;sockjs-client</a></p>
<h3 id="4-3-3-IE-8-and-9"><a href="#4-3-3-IE-8-and-9" class="headerlink" title="4.3.3. IE 8 and 9"></a>4.3.3. IE 8 and 9</h3><ul>
<li><input disabled="" type="checkbox"> TODO</li>
</ul>
<h3 id="4-3-4-Heartbeats"><a href="#4-3-4-Heartbeats" class="headerlink" title="4.3.4. Heartbeats"></a>4.3.4. Heartbeats</h3><p>SockJS 协议要求服务端发送心跳信息来防止代理判定连接挂起。</p>
<p>Spring SockJS 配置中有一个叫 <code>heartbeatTime</code> 的属性，可以自定义频率。默认情况下，如果连接上没有发送其他消息，将会在 25 秒后发送心跳。25 秒这个值符合 IETF 的建议。</p>
<p>💡 当在 WebSocket 和 SockJS 之上使用 STOMP时，如果 STOMP 客户端和服务端协商交换心跳，SockJS 的心跳将被禁用。</p>
<p>Spring SockJS 支持还允许您配置 <code>TaskScheduler</code> 来调度心跳任务。</p>
<p>任务调度器由线程池支持，其默认设置基于可用处理器的数量。您应该考虑根据您的具体需要自定义设置。</p>
<h3 id="4-3-5-Client-Disconnects"><a href="#4-3-5-Client-Disconnects" class="headerlink" title="4.3.5. Client Disconnects"></a>4.3.5. Client Disconnects</h3><p>在 Servlet 容器中，这是通过 Servlet 3 异步支持完成的，该支持允许退出Servlet容器线程，处理请求，并继续写入来自另一个线程的响应。</p>
<p>一个特定常见的问题是，Servlet API 不会通知客户端断开了连接。但是，Servlet 容器会在断开后写 response 时发生异常。由于 Spring s SockJS 服务支持服务器发送心跳（默认为每 25 秒），这意味着客户端断开连接通常在该时间段内被检测到（或者更早，如果消息发送更频繁的话）。</p>
<p>💡 因此，网络 I&#x2F;O 可能会因为客户端断开连接而发生错误，把无用的 stack traces 写入日志。Spring 尽最大努力识别表示客户端断开连接（特定于每个服务器）的网络故障，并通过使用专用的日志类别——断开连接的客户端日志类别（在 AbstractSockJsSession 中定义）记录最小的消息作为日志。If you need to see the stack traces, you can set that log category to TRACE.</p>
<h3 id="4-3-6-SockJS-and-CORS（跨域）"><a href="#4-3-6-SockJS-and-CORS（跨域）" class="headerlink" title="4.3.6. SockJS and CORS（跨域）"></a>4.3.6. SockJS and CORS（跨域）</h3><ul>
<li><input disabled="" type="checkbox"> TODO</li>
</ul>
<h3 id="4-3-7-SockJSClient"><a href="#4-3-7-SockJSClient" class="headerlink" title="4.3.7. SockJSClient"></a>4.3.7. SockJSClient</h3><p>Spring 提供了一个 SockJS Java 客户端来连接远程的 SockJS 端点，从而不需要使用浏览器。当需要在公共网络上（网络代理可能阻止 WebSocket 协议）的两台服务器之间进行双向通信时，这尤其有用。SockJS 的 Java 客户端也非常适用于测试场景（例如，模拟大量并发用户）。</p>
<ul>
<li><input disabled="" type="checkbox"> TODO</li>
</ul>
<h2 id="4-4-STOMP"><a href="#4-4-STOMP" class="headerlink" title="4.4. STOMP"></a>4.4. STOMP</h2><p>WebSocket 协议定义两种类型的消息（文本和二进制），但内容没有规范定义。</p>
<p>使用 STOMP 子协议是可选操作，因为无论采用哪种方式，客户端和服务端都需要达成一致。</p>
<h3 id="4-4-1-总览"><a href="#4-4-1-总览" class="headerlink" title="4.4.1. 总览"></a>4.4.1. 总览</h3><p>STOMP（Simple Text Oriented Protocol 简单的面向文本的消息传递协议）最初是为脚本语言创建，用于连接到企业消息代理。STOMP可以用于任何可靠的双向流媒体网络协议，如TCP和WebSocket。尽管说 STOMP 是面向文本的协议，但消息负载仍然既可以为文本或者是二进制。</p>
<p>STOMP 是基于 HTTP 的一种基于框架的协议，下面是 STOMP 框架的结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">COMMAND<br>header1:value1<br>header2:value2<br><br>Body^@<br></code></pre></td></tr></table></figure>

<p>客户端可以使用 <code>SEND</code> 或 <code>SUBSCRIBE</code> 命令发送或订阅消息，还可以使用 <code>destination</code> 标头来描述消息的内容以及谁应该接收消息。这支持一种简单的发布-订阅机制，您可以使用该机制通过代理将消息发送到其他连接的客户端，或将消息发送到服务器以请求执行某些工作。</p>
<p>当你使用 Spring 的 STOMP 支撑模块时，Spring WebSocket 应用充当客户端的 STOMP 代理。消息被路由到 <code>@Controller</code> 消息处理方法或是简单的内存代理，该代理能够追踪订阅以及向订阅用户广播消息。</p>
<p>Spring 也支持配置专用的 STOMP 代理（如 RabbitMQ、ActiveMQ等等）来进行消息广播。在这种情况下，Spring 维护到代理的 TCP 连接，将消息转发给代理，并将消息从代理向下传递到连接的 WebSocket 客户端。</p>
<p>因此，Spring Web 应用可以依赖统一的基于 HTTP 安全，公共校验，以及熟悉的编程模型来处理消息。</p>
<p>订阅示例</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">SUBSCRIBE<br>id:sub-1<br>destination:/topic/price.stock.*<br><br>^@<br></code></pre></td></tr></table></figure>

<p>客户端发送示例</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">SEND<br>destination:/queue/trade<br>content-type:application/json<br>content-length:44<br><br>&#123;&quot;action&quot;:&quot;BUY&quot;,&quot;ticker&quot;:&quot;MMM&quot;,&quot;shares&quot;,44&#125;^@<br></code></pre></td></tr></table></figure>

<p>服务端广播消息给订阅者</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">MESSAGE<br>message-id:nxahklf6-1<br>subscription:sub-1<br>destination:/topic/price.stock.MMM<br><br>&#123;&quot;ticker&quot;:&quot;MMM&quot;,&quot;price&quot;:129.45&#125;^@<br></code></pre></td></tr></table></figure>

<ul>
<li><input disabled="" type="checkbox"> TODO</li>
</ul>
<h3 id="4-4-2-好处"><a href="#4-4-2-好处" class="headerlink" title="4.4.2. 好处"></a>4.4.2. 好处</h3><ul>
<li><input disabled="" type="checkbox"> TODO</li>
</ul>
<h3 id="4-4-3-开启-STOMP"><a href="#4-4-3-开启-STOMP" class="headerlink" title="4.4.3. 开启 STOMP"></a>4.4.3. 开启 STOMP</h3><p>在 <code>spring-messaging</code> 和 <code>spring-websocket</code> 模块中提供了对WebSocket的支持。</p>
<p>配置示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;<br><span class="hljs-keyword">import</span> org.springframework.web.socket.config.annotation.StompEndpointRegistry;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSocketMessageBroker</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebSocketMessageBrokerConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerStompEndpoints</span><span class="hljs-params">(StompEndpointRegistry registry)</span> &#123;<br>				<span class="hljs-comment">// 1.声明 WebSocket/SockJS 客户端握手连接的 HTTP URL</span><br>        registry.addEndpoint(<span class="hljs-string">&quot;/portfolio&quot;</span>).withSockJS();  <br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureMessageBroker</span><span class="hljs-params">(MessageBrokerRegistry config)</span> &#123;<br>				<span class="hljs-comment">// 2.destination 头以 /app 为前缀的 STOMP 消息将路由到 @Controller 类中的 @MessageMapping 方法</span><br>        config.setApplicationDestinationPrefixes(<span class="hljs-string">&quot;/app&quot;</span>); <br>				<span class="hljs-comment">// 3.对于订阅和广播使用内置简单消息代理，路由destination 头以 /topic 和 /queue 为前缀的消息到代理</span><br>        config.enableSimpleBroker(<span class="hljs-string">&quot;/topic&quot;</span>, <span class="hljs-string">&quot;/queue&quot;</span>); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>💡 对于内置简单代理，<code>/topic</code> 和 <code>/queue</code> 并没有任何特殊含义。他们只是用来区分发布-订阅和点对点消息传递的一种约定。当使用外部代理时，请检查代理的 STOMP 页面，了解它支持哪种前缀。</p>
<p>关于 STOMP，可以选择的客户端库有</p>
<p><strong>项目中用到下面这个</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/jmesnil/stomp-websocket">jmesnil&#x2F;stomp-websocket</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/JSteunou/webstomp-client">webstomp-client</a></p>
<h3 id="4-4-4-WebSocket-Server-服务端配置"><a href="#4-4-4-WebSocket-Server-服务端配置" class="headerlink" title="4.4.4. WebSocket Server 服务端配置"></a>4.4.4. WebSocket Server 服务端配置</h3><p>在上面的 <code>开启 STOMP</code> 部分已经提到，不再重复。</p>
<h3 id="4-4-5-Flow-of-Messages-消息流"><a href="#4-4-5-Flow-of-Messages-消息流" class="headerlink" title="4.4.5. Flow of Messages 消息流"></a>4.4.5. Flow of Messages 消息流</h3><p>一旦 STOMP 端点暴露出来，Spring应用就成为客户端连接的 STOMP 代理服务。</p>
<p><code>spring-messaging</code> 的一些抽象组件如下：</p>
<ul>
<li>Message：简单的消息，包括 header 和 payload。</li>
<li>MessageHandler：用于处理消息</li>
<li>MessageChannel：用于解构生产者和消费者发送消息这一过程</li>
<li>SubscribeChannel：MessageChannel with MessageHandler subscribers.</li>
<li>ExecutorSubscribableChannel：SubscribableChannel that uses an Executor for delivering messages.</li>
</ul>
<p>使用 Java 配置类（@EnableWebSocketMessageBroker）或是 XML 配置（<a href="websocket:message-broker">websocket:message-broker</a>）都使用上面的组件来组装消息工作流。</p>
<p>下图展示了启用内置消息代理时用到的组件：</p>
<p><img src="/note-of-websocket/Untitled%202.png" srcset="/img/loading.gif" lazyload alt="note-of-websocket%2029723de254c64768a5242417d6575173/Untitled%202.png"></p>
<p>上图展示了 3 个消息频道：</p>
<ul>
<li><code>clientInboundChannel</code>: For passing messages received from WebSocket clients.</li>
<li><code>clientOutboundChannel</code>: For sending server messages to WebSocket clients.</li>
<li><code>brokerChannel</code>: For sending messages to the message broker from within server-side application code.</li>
</ul>
<p>下图展示了配置外部代理（如 RabbitMQ）来管理订阅和广播消息时使用的组件：</p>
<p><img src="/note-of-websocket/Untitled%203.png" srcset="/img/loading.gif" lazyload alt="note-of-websocket%2029723de254c64768a5242417d6575173/Untitled%203.png"></p>
<p>以上最主要区别是使用了 <code>broker relay</code> 来通过 TCP 将消息向上传递到外部 STOMP 代理，以及将消息从代理向下传递到订阅的客户端。</p>
<p>WebSocket 连接发送的消息，会被解码成 STOMP 帧，转化成 Spring <code>Message</code>  表示，并被发送到 <code>clientInboundChannel</code> 做进一步处理。比如，以 <code>/app</code> 开头的消息会被路由到 controller 注解类中的 <code>@MessageMapping</code> 方法，以 <code>/topic</code> 和 <code>/queue</code> 开头的消息会被直接路由到消息代理。</p>
<p>An annotated @Controller that handles a STOMP message from a client may send a message to the message broker through the brokerChannel, and the broker broadcasts the message to matching subscribers through the clientOutboundChannel. The same controller can also do the same in response to HTTP requests, so a client can perform an HTTP POST, and then a @PostMapping method can send a message to the message broker to broadcast to subscribed clients.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%88%86%E7%B1%BB/" class="category-chain-item">分类</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/websocket/">#websocket</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/note-of-hystrix" title="Hystrix 笔记">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Hystrix 笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/note-of-spring-security" title="Spring Security 笔记">
                        <span class="hidden-mobile">Spring Security 笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'quan7u/quan7u.github.io');
      s.setAttribute('issue-term', 'url');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
